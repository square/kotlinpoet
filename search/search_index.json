{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KotlinPoet","text":"<p><code>KotlinPoet</code> is a Kotlin and Java API for generating <code>.kt</code> source files.</p> <p>Source file generation can be useful when doing things such as annotation processing or interacting with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate the need to write boilerplate while also keeping a single source of truth for the metadata.</p>"},{"location":"#example","title":"Example","text":"<p>Here\u2019s a <code>HelloWorld</code> file:</p> <pre><code>class Greeter(val name: String) {\n  fun greet() {\n    println(\"\"\"Hello, $name\"\"\")\n  }\n}\n\nfun main(vararg args: String) {\n  Greeter(args[0]).greet()\n}\n</code></pre> <p>And this is the code to generate it with KotlinPoet:</p> <pre><code>val greeterClass = ClassName(\"\", \"Greeter\")\nval file = FileSpec.builder(\"\", \"HelloWorld\")\n  .addType(\n    TypeSpec.classBuilder(\"Greeter\")\n      .primaryConstructor(\n        FunSpec.constructorBuilder()\n          .addParameter(\"name\", String::class)\n          .build()\n      )\n      .addProperty(\n        PropertySpec.builder(\"name\", String::class)\n          .initializer(\"name\")\n          .build()\n      )\n      .addFunction(\n        FunSpec.builder(\"greet\")\n          .addStatement(\"println(%P)\", \"Hello, \\$name\")\n          .build()\n      )\n      .build()\n  )\n  .addFunction(\n    FunSpec.builder(\"main\")\n      .addParameter(\"args\", String::class, VARARG)\n      .addStatement(\"%T(args[0]).greet()\", greeterClass)\n      .build()\n  )\n  .build()\n\nfile.writeTo(System.out)\n</code></pre> <p>The KDoc catalogs the complete KotlinPoet API, which is inspired by JavaPoet.</p> <p>Note: In order to maximize portability, KotlinPoet generates code with explicit visibility modifiers. This ensures compatibility with both standard Kotlin projects as well as projects using explicit API mode. Examples in the documentation omit those modifiers for brevity.</p>"},{"location":"#download","title":"Download","text":"<p>Download the latest .jar or depend via Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n  &lt;artifactId&gt;kotlinpoet-jvm&lt;/artifactId&gt;\n  &lt;version&gt;[version]&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>or Gradle:</p> <pre><code>implementation(\"com.squareup:kotlinpoet:[version]\")\n</code></pre> <p>Snapshots of the development version are available in the Central Portal Snapshots repository.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2017 Square, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"annotations/","title":"Annotations","text":"<p>Simple annotations are easy:</p> <pre><code>val test = FunSpec.builder(\"test string equality\")\n  .addAnnotation(Test::class)\n  .addStatement(\"assertThat(%1S).isEqualTo(%1S)\", \"foo\")\n  .build()\n</code></pre> <p>Which generates this function with an <code>@Test</code> annotation:</p> <pre><code>@Test\nfun `test string equality`() {\n  assertThat(\"foo\").isEqualTo(\"foo\")\n}\n</code></pre> <p>Use <code>AnnotationSpec.builder()</code> to set properties on annotations:</p> <pre><code>val logRecord = FunSpec.builder(\"recordEvent\")\n  .addModifiers(KModifier.ABSTRACT)\n  .addAnnotation(\n    AnnotationSpec.builder(Headers::class)\n      .addMember(\"accept = %S\", \"application/json; charset=utf-8\")\n      .addMember(\"userAgent = %S\", \"Square Cash\")\n      .build()\n  )\n  .addParameter(\"logRecord\", LogRecord::class)\n  .returns(LogReceipt::class)\n  .build()\n</code></pre> <p>Which generates this annotation with <code>accept</code> and <code>userAgent</code> properties:</p> <pre><code>@Headers(\n  accept = \"application/json; charset=utf-8\",\n  userAgent = \"Square Cash\"\n)\nabstract fun recordEvent(logRecord: LogRecord): LogReceipt\n</code></pre> <p>When you get fancy, annotation values can be annotations themselves. Use <code>%L</code> for embedded annotations:</p> <pre><code>val headerList = ClassName(\"\", \"HeaderList\")\nval header = ClassName(\"\", \"Header\")\nval logRecord = FunSpec.builder(\"recordEvent\")\n  .addModifiers(KModifier.ABSTRACT)\n  .addAnnotation(\n    AnnotationSpec.builder(headerList)\n      .addMember(\n        \"[\\n\u21e5%L,\\n%L\u21e4\\n]\",\n        AnnotationSpec.builder(header)\n          .addMember(\"name = %S\", \"Accept\")\n          .addMember(\"value = %S\", \"application/json; charset=utf-8\")\n          .build(),\n        AnnotationSpec.builder(header)\n          .addMember(\"name = %S\", \"User-Agent\")\n          .addMember(\"value = %S\", \"Square Cash\")\n          .build()\n      )\n      .build()\n  )\n  .addParameter(\"logRecord\", logRecordName)\n  .returns(logReceipt)\n  .build()\n</code></pre> <p>Which generates this:</p> <pre><code>@HeaderList(\n  [\n    Header(name = \"Accept\", value = \"application/json; charset=utf-8\"),\n    Header(name = \"User-Agent\", value = \"Square Cash\")\n  ]\n)\nabstract fun recordEvent(logRecord: LogRecord): LogReceipt\n</code></pre> <p>KotlinPoet supports use-site targets for annotations:</p> <pre><code>val utils = FileSpec.builder(\"com.example\", \"Utils\")\n  .addAnnotation(\n    AnnotationSpec.builder(JvmName::class)\n      .useSiteTarget(UseSiteTarget.FILE)\n      .build()\n  )\n  .addFunction(\n    FunSpec.builder(\"abs\")\n      .receiver(Int::class)\n      .returns(Int::class)\n      .addStatement(\"return if (this &lt; 0) -this else this\")\n      .build()\n  )\n  .build()\n</code></pre> <p>Will output this:</p> <pre><code>@file:JvmName\n\npackage com.example\n\nimport kotlin.Int\nimport kotlin.jvm.JvmName\n\nfun Int.abs(): Int = if (this &lt; 0) -this else this\n</code></pre>"},{"location":"anonymous-inner-classes/","title":"Anonymous Inner Classes","text":"<p>In the enum code, we used <code>TypeSpec.anonymousClassBuilder()</code>. Anonymous inner classes can also be used in code blocks. They are values that can be referenced with <code>%L</code>:</p> <pre><code>val comparator = TypeSpec.anonymousClassBuilder()\n  .addSuperinterface(Comparator::class.parameterizedBy(String::class))\n  .addFunction(\n    FunSpec.builder(\"compare\")\n      .addModifiers(KModifier.OVERRIDE)\n      .addParameter(\"a\", String::class)\n      .addParameter(\"b\", String::class)\n      .returns(Int::class)\n      .addStatement(\"return %N.length - %N.length\", \"a\", \"b\")\n      .build()\n  )\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addFunction(\n    FunSpec.builder(\"sortByLength\")\n      .addParameter(\"strings\", List::class.parameterizedBy(String::class))\n      .addStatement(\"%N.sortedWith(%L)\", \"strings\", comparator)\n      .build()\n  )\n  .build()\n</code></pre> <p>This generates a method that contains a class that contains a method:</p> <pre><code>class HelloWorld {\n  fun sortByLength(strings: List&lt;String&gt;) {\n    strings.sortedWith(object : Comparator&lt;String&gt; {\n      override fun compare(a: String, b: String): Int = a.length - b.length\n    })\n  }\n}\n</code></pre> <p>One particularly tricky part of defining anonymous inner classes is the arguments to the superclass constructor. To pass them use <code>TypeSpec.Builder</code>\u2019s <code>addSuperclassConstructorParameter()</code> method.</p>"},{"location":"callable-references/","title":"Callable References","text":"<p>Callable references to constructors, functions, and properties may be emitted via:</p> <ul> <li><code>ClassName.constructorReference()</code> for constructors</li> <li><code>MemberName.reference()</code> for functions and properties</li> </ul> <p>For example,</p> <pre><code>val helloClass = ClassName(\"com.example.hello\", \"Hello\")\nval worldFunction: MemberName = helloClass.member(\"world\")\nval byeProperty: MemberName = helloClass.nestedClass(\"World\").member(\"bye\")\n\nval factoriesFun = FunSpec.builder(\"factories\")\n  .addStatement(\"val hello = %L\", helloClass.constructorReference())\n  .addStatement(\"val world = %L\", worldFunction.reference())\n  .addStatement(\"val bye = %L\", byeProperty.reference())\n  .build()\n\nFileSpec.builder(\"com.example\", \"HelloWorld\")\n  .addFunction(factoriesFun)\n  .build()\n</code></pre> <p>would generate:</p> <pre><code>package com.example\n\nimport com.example.hello.Hello\n\nfun factories() {\n  val hello = ::Hello\n  val world = Hello::world\n  val bye = Hello.World::bye\n}\n</code></pre> <p>Top-level classes and members with conflicting names may require aliased imports, as with member names.</p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>New: Add support for type aliases in types.</li> <li>New: Add <code>FileSpec.addImport(MemberName)</code> to explicitly import a member (#2198)</li> <li>New: Add <code>NameAllocator.contains</code> to check if a given tag is already allocated (#2154)</li> <li>Fix: <code>emitNullable</code> correctly when deferring type in <code>CodeWriter</code>. (#2216)</li> <li>Fix: <code>FunSpec.beginControlFlow</code> to accept nullable arguments for consistency with <code>CodeBlock.beginControlFlow</code>. (#2174)</li> <li>Fix: Annotation array parameters with annotation elements now correctly handled. (#2142)</li> <li>Fix: <code>KType.asTypeName</code> now correctly handles recursively bound generics (e.g. <code>T : Comparable&lt;T&gt;</code>). (#1914)</li> <li>Fix: Don\u2019t convert multi-statement function to expression body. (#1979)</li> <li>In-development snapshots are now published to the Central Portal Snapshots repository at https://central.sonatype.com/repository/maven-snapshots/.</li> </ul>"},{"location":"changelog/#version-220","title":"Version 2.2.0","text":"<p>Thanks to @IRus for contributing to this release.</p> <p>2025-05-16</p> <ul> <li>New: Kotlin 2.1.21.</li> <li>New: KSP 2.1.21-2.0.1.</li> <li>New: Add support for context parameters. (#2112)</li> <li>New: Eliminate Guava dependency. (#2110)</li> <li>New: Migrate to Dokka plugin V2. (#2113)</li> </ul>"},{"location":"changelog/#version-210","title":"Version 2.1.0","text":"<p>Thanks to @ForteScarlet, @TrevorSStone, @RaoPrashanth, @damianw, @ansehoon1999, @TheMrMilchmann for contributing to this release.</p> <p>2025-02-25</p> <ul> <li>New: Kotlin 2.1.10.</li> <li>New: KSP 2.1.10-1.0.30.</li> <li>Fix: Support delegates on anonymous classes. (#2034)</li> <li>Fix: Prevent aliased imports from colliding with existing imports. (#2052)</li> <li>Fix: <code>TypeName.MUTABLE_MAP_ENTRY</code> now correctly uses the <code>MutableEntry</code> nested class name. (#2061)</li> <li>Fix: Use the same aliased import for both the nullable and non-nullable versions of a type. (#2068)</li> <li>Fix: Allow zero methods in a functional interface if it has a superinterface. (#2075)</li> </ul>"},{"location":"changelog/#version-200","title":"Version 2.0.0","text":"<p>Thanks to @brokenhappy, @tajobe, @niyajali, @ForteScarlet for contributing to this release.</p> <p>2024-10-23</p> <p>This release is source- and binary-compatible with KotlinPoet 1.x.</p> <p>The most important behavior change in this release is that spaces in generated code don\u2019t wrap by default anymore.</p> <p>KotlinPoet 1.x used to replace space characters with newline characters whenever a given line of code exceeded the length limit. This usually led to better code formatting, but could also lead to compilation errors in generated code. Non-breaking spaces could be marked by the <code>\u00b7</code> character, but the discoverability of this feature wasn\u2019t great.</p> <p>KotlinPoet 2.0 does not wrap spaces, even if the line of code they occur in exceeds the length limit. The newly introduced <code>\u2662</code> character can be used to mark spaces that are safe to wrap, which can improve code formatting. The <code>\u00b7</code> character has been preserved for compatibility, but its behavior is now equivalent to a regular space character.</p> <ul> <li>New: Kotlin 2.0.10.</li> <li>New: Spaces don\u2019t break by default.</li> <li>New: New <code>\u2662</code> placeholder representing a space that is safe to wrap.</li> <li>New: Add <code>KSTypeAlias.toClassName()</code>. (#1956)</li> <li>New: Add <code>KSType.toClassNameOrNull()</code>. (#1956)</li> <li>Fix: Enum classes that only have an init block now also generate the required semicolon. (#1953)</li> <li>Fix: Preserve typealiases in <code>KSAnnotation.toAnnotationSpec()</code>. (#1956)</li> <li>Fix: Preserve nullability in <code>KSType.toClassName()</code>. (#1956)</li> </ul>"},{"location":"changelog/#version-1181","title":"Version 1.18.1","text":"<p>Thanks to @mitasov-ra for contributing to this release.</p> <p>2024-07-15</p> <ul> <li>Fix: Workaround for KT-18706: KotlinPoet now generates import aliases without backticks (#1920).</li> </ul> <pre><code>// before, doesn't compile due to KT-18706\nimport com.example.one.`$Foo` as `One$Foo`\nimport com.example.two.`$Foo` as `Two$Foo`\n\n// now, compiles\nimport com.example.one.`$Foo` as One__Foo\nimport com.example.two.`$Foo` as Two__Foo\n</code></pre>"},{"location":"changelog/#version-1180","title":"Version 1.18.0","text":"<p>Thanks to @DanielGronau for contributing to this release.</p> <p>2024-07-05</p> <ul> <li>New: Kotlin 2.0.0.</li> <li>New: KSP 2.0.0-1.0.22.</li> <li>New: Promote <code>kotlinpoet-metadata</code> out of preview to stable.</li> <li>New: Migrate <code>kotlinpoet-metadata</code> to stable <code>org.jetbrains.kotlin:kotlin-metadata-jvm</code> artifact for Metadata parsing.</li> <li>New: Make enum entry references in <code>KSAnnotation.toAnnotationSpec()</code> and <code>KSClassDeclaration.toClassName()</code> more robust.</li> <li>Fix: Don\u2019t expand typealiases of function types to <code>LambdaTypeName</code>s in <code>KSTypeReference.toTypeName()</code>.</li> <li>Fix: Avoid rounding small double and float values in <code>%L</code> translation (#1927).</li> <li>Fix: Fix typealias type argument resolution in KSP2 (#1929).</li> </ul>"},{"location":"changelog/#version-1170","title":"Version 1.17.0","text":"<p>Thanks to @jisungbin, @hfhbd, @evant, @sgjesse, @sebek64 for contributing to this release.</p> <p>2024-05-24</p> <ul> <li>Change: kotlinx-metadata 0.9.0. Note that the <code>KotlinClassMetadata.read</code> is deprecated in 0.9.0 and replaced with   <code>readStrict</code> (#1830).</li> <li>Note: we now also provide <code>lenient</code> parameters to map to the underlying <code>readStrict()</code> and <code>readLenient()</code> calls     (#1766).</li> <li>We have also removed various <code>Class</code>/<code>TypeElement</code>/<code>Metadata</code>-to-<code>KmClass</code> APIs from the public API, as these are     trivial to write now with kotlinx-metadata\u2019s newer APIs and allows us to focus the API surface area of this artifact     better (#1891).</li> <li>New: Supertype list wraps to one-per-line if the primary constructor spans multiple lines (#1866).</li> <li>New: Extract <code>MemberSpecHolder</code> interface for constructs that can hold <code>PropertySpec</code>s and <code>FunSpec</code>s and their   builders (#1877).</li> <li>New: <code>joinToCode</code> variant which operates on any type, but requires a transform lambda to convert each element into a   <code>CodeBlock</code> (#1874).</li> <li>New: Support annotation type arguments in <code>KSAnnotation.toAnnotationSpec()</code> (#1889).</li> <li>Fix: Prevent name clashes between a function in class and a function call in current scope (#1850).</li> <li>Fix: Fix extension function imports (#1814).</li> <li>Fix: Omit implicit modifiers on <code>FileSpec.scriptBuilder</code> (#1813).</li> <li>Fix: Fix trailing newline in <code>PropertySpec</code> (#1827).</li> <li>Fix: <code>KSAnnotation.toAnnotationSpec</code> writes varargs in place instead of making them an array to work around a Kotlin   issue with <code>OptIn</code> annotations (#1833).</li> <li>Fix: <code>MemberName</code>s without a package are now correctly imported (#1841)</li> <li>Fix: Throw if primary constructor delegates to other constructors (#1859).</li> <li>Fix: Aliased imports with nested class (#1876).</li> <li>Fix: Check for error types in <code>KSType.toClassName()</code> (#1890).</li> <li>Fix: Support generating a single import for overloaded <code>MemberName</code>s (#1909).</li> </ul>"},{"location":"changelog/#version-1160","title":"Version 1.16.0","text":"<p>Thanks to @drawers, @rickclephas for contributing to this release.</p> <p>2024-01-18</p> <ul> <li>New: Kotlin 1.9.22.</li> <li>New: KSP 1.9.22-1.0.16.</li> <li>New: Add <code>NameAllocator</code> API to control keyword pre-allocation (#1803).</li> <li>Fix: Fix issue with missing <code>suspend</code> modifier in <code>KSTypeReference.toTypeName</code> (#1793).</li> <li>Fix: Honour same-package import aliases (#1794).</li> <li>Fix: Always include parameter docs in the type header (#1800).</li> </ul>"},{"location":"changelog/#version-1153","title":"Version 1.15.3","text":"<p>Thanks to @gabrielittner for contributing to this release.</p> <p>2023-12-04</p> <ul> <li>Fix: Fix nullability of lambdas in <code>KSTypeReference.toTypeName</code> (#1756).</li> </ul>"},{"location":"changelog/#version-1152","title":"Version 1.15.2","text":"<p>Thanks to @evant for contributing to this release.</p> <p>2023-11-30</p> <ul> <li>New: Kotlin 1.9.21.</li> <li>New: KSP 1.9.21-1.0.15.</li> <li>New: KSP: more accurately represent function types (#1742).</li> </ul>"},{"location":"changelog/#version-1151","title":"Version 1.15.1","text":"<p>2023-11-19</p> <ul> <li>Fix: Fix a regression introduced by #1637, where a superfluous newline is added to a type\u2019s KDoc  if it has a primary constructor with no docs (#1727).</li> </ul>"},{"location":"changelog/#version-1150","title":"Version 1.15.0","text":"<p>2023-11-18</p> <p>Thanks to @drawers, @fejesjoco, @takahirom, @martinbonnin, @mcarleio for contributing to this release.</p> <p>In this release the <code>:kotlinpoet</code> module has been converted to a Kotlin Multiplatform module (#1654), though for now it only supports the JVM target. Important: unless you\u2019re building with Gradle, you will now need to depend on the <code>kotlinpoet-jvm</code> artifact, instead of <code>kotlinpoet</code> - see Downloads for instructions.</p> <ul> <li>New: Kotlin 1.9.20.</li> <li>New: KSP 1.9.20-1.0.14.</li> <li>New: Extract <code>TypeSpecHolder</code> interface for constructs that can hold a TypeSpec and their builders (#1723).</li> <li>New: Expose relative path from <code>FileSpec</code> (#1720).</li> <li>New: Return the generated path from <code>FileSpec.writeTo()</code>. (#1514).</li> <li>New: Remove default compatibility from unstable types (#1662).</li> <li>New: Deprecate <code>TypeSpec.expectClassBuilder()</code> and <code>TypeSpec.valueClassBuilder()</code> (#1589).</li> <li>New: Add option to convert <code>KSAnnotation</code> to <code>AnnotationSpec</code> while omitting default values (#1538).</li> <li>New: Add <code>FileSpec.builder</code> convenience for <code>MemberName</code> (#1585).</li> <li>Fix: Set <code>DecimalFormatSymbols.minusSign</code> for consistency across locales (#1658).</li> <li>Fix: Fix link to incremental KSP in KDoc (#1638).</li> <li>Fix: Emit primary constructor KDoc (#1637).</li> <li>Change: kotlinx-metadata 0.7.0. This is a breaking change for users of the <code>:kotlinpoet-metadata</code>    module, as most <code>Flags</code>-API extensions have been removed in favor of the now-available first-party versions.</li> </ul>"},{"location":"changelog/#version-1142","title":"Version 1.14.2","text":"<p>2023-05-30</p> <ul> <li>Fix: Fix one more missing API in binary compatibility override in <code>Annotatable.Builder</code> (#1581).</li> </ul>"},{"location":"changelog/#version-1141","title":"Version 1.14.1","text":"<p>2023-05-29</p> <ul> <li>Fix: Restore ABI stability for annotatable and documentable builders (#1580).</li> </ul>"},{"location":"changelog/#version-1140","title":"Version 1.14.0","text":"<p>2023-05-29</p> <p>Thanks to @Omico, @drawers, @RBusarow for contributing to this release.</p> <ul> <li>New: Kotlin 1.8.21.</li> <li>New: KSP 1.8.21-1.0.11.</li> <li>New: Enable default methods in Java bytecode (#1561).</li> <li>New: Group Kotlin and Renovate updates together in Renovate (#1562).</li> <li>New: Extract trait interface for annotatable constructs and their builders (#1564).</li> <li>New: Extract trait interface for documentable constructs and their builders (#1571).</li> <li>New: Document the usage of <code>STAR</code> (#1572).</li> <li>New: Add builder for <code>FunSpec</code> which accepts a <code>MemberName</code> (#1574).</li> <li>Fix: Omit public modifier on override function or constructor parameters (#1550).</li> <li>Fix: Correct handling of members in various types (#1558).</li> <li> <p>Fix: Function return types now default to <code>Unit</code> unless explicitly set (#1559).</p> <p>Previously, when <code>FunSpec</code> didn\u2019t have a return type specified and an expression body was produced, no return type would be emitted. However, starting from <code>1.14.0</code>, KotlinPoet will not add <code>Unit</code> as a return type in such cases. In order to correct the generated output, you are to specify the actual return type of the <code>FunSpec</code>.</p> <p>Before <code>1.14.0</code>, if omitted, no return type is produced: <pre><code>val funSpec = FunSpec.builder(\"foo\")\n  .addStatement(\"return 1\")\n  .build()\n</code></pre> <pre><code>public fun foo() = 1\n</code></pre></p> <p>From <code>1.14.0</code>, the return type defaults to <code>Unit</code> if not otherwise set: <pre><code>val funSpec = FunSpec.builder(\"foo\")\n  .addStatement(\"return 1\")\n  .build()\n</code></pre> <pre><code>public fun foo(): Unit = 1 // \u274c\n</code></pre></p> <p>To fix it, explicitly define the return type: <pre><code> val funSpec = FunSpec.builder(\"foo\")\n+  .returns(INT)\n   .addStatement(\"return 1\")\n   .build()\n</code></pre> <pre><code>public fun foo(): Int = 1 // \u2705\n</code></pre></p> <p>Additionally, as part of this change, <code>FunSpec.returnType</code> has changed to be non-nullable. This is a source- and binary-compatible change, although if you were performing null-checks then new warnings may appear after upgrade.</p> </li> <li> <p>Fix: Append nested class names to alias during name lookup (#1568).</p> </li> <li>Fix: Allow PropertySpec with context receivers and without getter or setter (#1575).</li> </ul>"},{"location":"changelog/#version-1132","title":"Version 1.13.2","text":"<p>2023-05-05</p> <p>Thanks to @Squiry for contributing to this release.</p> <ul> <li>Fix: <code>KSType.toTypeName</code> fixed to work with aliased types (#1534).</li> </ul>"},{"location":"changelog/#version-1131","title":"Version 1.13.1","text":"<p>2023-04-28</p> <p>Thanks to @rickclephas for contributing to this release.</p> <ul> <li>Fix: Look at canonical names instead of just package names when generating import aliases (#1519).</li> <li>Fix: Ignore KSP annotation arguments without a value (#1523).</li> <li>Fix: Fix arguments handling in <code>KSType.toTypeName()</code> (#1529).</li> </ul>"},{"location":"changelog/#version-1130","title":"Version 1.13.0","text":"<p>2023-04-06</p> <p>Thanks to @popematt, @bitPogo, @mars885, @sjudd, @Sironheart, @polarene, @DeoTimeTheGithubUser, @drawers for contributing to this release.</p> <ul> <li>New: Kotlin 1.8.0.</li> <li>New: KSP 1.8.0-1.0.9.</li> <li>New: Support context receivers on TypeSpecs + extract ContextReceivable API (#1269).</li> <li>New: Optimize <code>OriginatingElements</code> and <code>TagMap</code> implementations (#1270).</li> <li>New: Auto-generate import aliases for types and members (#1355).</li> <li>New: Insert underscores into large decimal literals (#1384).</li> <li>New: New factory function <code>FileSpec.builder(ClassName)</code> (#1397).</li> <li>Fix: Fix StackOverflowError when calling <code>KSTypeArgument.toTypeName()</code> for a wildcard in a recursive type bound (#1272).</li> <li>Fix: Fix transitive aliases (#1306).</li> <li>Fix: Fix Aliases as TypeArgument (#1321).</li> <li>Fix: Don\u2019t escape special characters inside raw strings (#1331).</li> <li>Fix: Fix KSP interop\u2019s output of the annotation parameter value of type Char (#1338).</li> <li>Fix: Fix KSP interop\u2019s output for primitive arrays (#1340).</li> <li>Fix: Avoid emitting public if <code>shouldEmitPublicModifier</code> returns false (#1342).</li> <li>Fix: Fix context receivers being rendered in an incorrect position when on a nullable/suspending <code>LambdaTypeName</code> (#1454).</li> <li>Fix: Do not use <code>bestGuess</code> for <code>KClass.asClassName</code> (#1469).</li> <li>Fix: Handle fake nested types with platform mapped parents (#1472).</li> <li>Fix: Fix <code>TypeName</code> equals (#1477).</li> <li>Fix: Make equals consistent with compareTo for <code>ClassName</code> (#1506).</li> </ul>"},{"location":"changelog/#version-1120","title":"Version 1.12.0","text":"<p>2022-06-13</p> <p>Thanks to @WhosNickDoglio, @sullis, @DRSchlaubi, @martinbonnin, @seriouslyhypersonic, @ephemient, @dkilmer, @aksh1618, @zsqw123, @roihershberg for contributing to this release.</p> <ul> <li>New: Kotlin 1.7.0.</li> <li>New: Add support for context receivers.</li> <li>New: Add support for external property getter.</li> <li>New: <code>interop-ksp</code> API promoted to stable.</li> <li>Fix: Resolve enum constants when emitting types.</li> <li>Fix: Fix type argument mapping when processing typealiases with KSP.</li> <li>Fix: Properly unwrap <code>KSTypeAlias</code> with an unused type parameter.</li> <li>Fix: Unwrap nested <code>KSTypeAlias</code>-es recursively.</li> <li>Fix: Add support for context receivers <code>@PropertySpec</code> and fix issues with annotations.</li> <li>Fix: Treat <code>header</code> and <code>impl</code> as keywords (workaround for KT-52315).</li> <li>Fix: Use <code>%N</code> instead of <code>%L</code> for annotation arg names so keywords are handled.</li> <li>Fix: Improve handling of long <code>return</code> expressions.</li> </ul>"},{"location":"changelog/#version-1110","title":"Version 1.11.0","text":"<p>2022-03-24</p> <p>Thanks to @liujingxing and @BoD for contributing to this release.</p> <ul> <li>New: Kotlin scripting support in <code>FileSpec</code>.</li> </ul> <pre><code>val spec = FileSpec.scriptBuilder(\"Taco\")\n  .addStatement(\"println(%S)\", \"hello world!\")\n  .addKotlinDefaultImports()\n  .build()\n</code></pre> <p>Generates a <code>Taco.kts</code> file with the following contents:</p> <pre><code>println(\"hello world!\")\n</code></pre> <ul> <li>New: Emit trailing commas for multi-line parameters and annotations.</li> <li>New: Add <code>KSAnnotation.toAnnotationSpec()</code>.</li> <li>New: Add <code>Unit</code> and <code>CharSequence</code> conversions in <code>javapoet-interop</code>.</li> <li>New: Add support for default imports in <code>FileSpec</code>.</li> <li>This is particularly oriented at scripting support, but can also be used in non-script files.</li> <li>New: Update to Kotlin 1.6.10.</li> <li>Fix: Fail compilation if you only pass one string to <code>ClassName</code>.</li> <li>Fix: Inline <code>val</code> property if its getter is <code>inline</code>.</li> <li>Fix: Add <code>yield</code> to the list of reserved keywords.</li> <li>Fix: Enforce only allowed parameter modifiers in <code>ParameterSpec</code> (i.e. <code>crossinline</code>, <code>vararg</code>, and <code>noinline</code>).</li> <li>Fix: Fix <code>CodeBlock</code>s in class delegation getting <code>toString()</code>\u2018d instead of participating in code writing.</li> <li>Fix: Error when attempting to convert KSP error types (i.e. if <code>KSType.isError</code> is true) to <code>TypeName</code>.</li> </ul>"},{"location":"changelog/#version-1102","title":"Version 1.10.2","text":"<p>2021-10-22</p> <p>Thanks to @glureau and @goooler for contributing to this release.</p> <ul> <li>New: Switch <code>AnnotationSpec.get()</code> to use the <code>arrayOf()</code> syntax instead of <code>[]</code>.</li> <li>Fix: Don\u2019t wrap aliasing imports with long package names.</li> <li>Fix: Don\u2019t wrap type names inside line comments.</li> <li>Fix: Ignore Java\u2019s <code>@Deprecated</code> annotations on synthetic methods for annotations.</li> </ul>"},{"location":"changelog/#version-1101","title":"Version 1.10.1","text":"<p>2021-09-21</p> <p>Thanks to @evant for contributing to this release.</p> <ul> <li>Fix: Correct generation of typealiases with type args in KSP interop.</li> <li>Fix: Add missing default <code>TypeParameterResolver.EMPTY</code> argument to    <code>fun KSTypeArgument.toTypeName</code> in KSP interop.</li> </ul>"},{"location":"changelog/#version-1100","title":"Version 1.10.0","text":"<p>2021-09-20</p> <p>Thanks to @martinbonnin, @idanakav, @goooler, and @anandwana001 for contributing to this release.</p> <ul> <li>New: Add a new KSP interop artifact. See docs for more details.</li> <li>New: Add a new JavaPoet interop artifact. See docs for more    details.</li> <li>New: Allow copying a <code>ParameterizedTypeName</code> with new type arguments via new <code>copy()</code> overload.</li> <li>kotlinx-metadata artifacts have been consolidated to a single <code>com.squareup:kotlinpoet-metadata</code>    maven artifact. The previous <code>kotlinpoet-metadata-*</code> subartifacts are no longer published.</li> <li>New: <code>TypeNameAliasTag</code> has been moved to KotlinPoet\u2019s main artifact under <code>TypeAliasTag</code>, for    reuse with KSP interop.</li> <li><code>ImmutableKm*</code> classes have been removed. They were deemed to be a needless abstraction over the base <code>kotlinx-metadata</code> Km types. All usages of these should be substituted with their non-immutable base types.</li> <li>Fix: Fix self-referencing type variables in metadata parsing.</li> <li>Fix: Use delicate APIs rather than noisy logging ones when converting annotation mirrors in    <code>AnnotationSpec.get</code>.</li> <li>Fix: Update error message when metadata cannot be read to a more actionable one.</li> <li>Fix: Avoid escaping already escaped strings.</li> <li>Add docs about <code>kotlin-reflect</code> usage.</li> <li>Avoid using kotlin-reflect for looking up <code>Unit</code> types where possible.</li> <li>Test all the way up to JDK 17.</li> <li>Update Kotlin to 1.5.31.</li> </ul>"},{"location":"changelog/#version-190","title":"Version 1.9.0","text":"<p>2021-06-22</p> <ul> <li>New: Kotlin 1.5.10.</li> <li>New: Previously deprecated API to interop with Java reflection and Mirror API have been    un-deprecated and marked with <code>@DelicateKotlinPoetApi</code> annotation.</li> <li>New: <code>CodeBlock.Builder.withIndent</code> helper function.</li> <li>New: Allow changing initializers and default values in <code>ParameterSpec.Builder</code> and    <code>PropertySpec.Builder</code> after they were set.</li> <li>New: <code>MemberName.isExtension</code> property that instructs KotlinPoet to always import the member,    even if conflicting declarations are present in the same scope.</li> <li>Fix: Escape member names that only contain underscores.</li> <li>Fix: Always emit an empty primary constructor if it was set via <code>TypeSpec.primaryConstructor</code>.</li> </ul>"},{"location":"changelog/#version-180","title":"Version 1.8.0","text":"<p>2021-03-29</p> <ul> <li>New: Kotlin 1.4.31.</li> <li>New: Add <code>KModifier.VALUE</code> to support <code>value class</code> declarations.</li> <li>New: Allow using a custom <code>ClassLoader</code> with <code>ReflectiveClassInspector</code>.</li> <li>New: Update to kotlinx-metadata 0.2.0.</li> <li>Fix: Ensure <code>ImmutableKmProperty.toMutable()</code> copies <code>fieldSignature</code>.</li> <li>Fix: Prevent name clashes between an imported <code>MemberName</code> and a member in current scope.</li> <li>Fix: Prevent name clashes between a type and a supertype with the same name.</li> <li>Fix: Don\u2019t generate empty body for <code>expect</code> and <code>external</code> functions.</li> <li>Fix: Don\u2019t allow <code>expect</code> or <code>external</code> classes to initialize supertypes.</li> <li>Fix: Disallow delegate constructor calls in <code>external</code> classes.</li> <li>Fix: Allow non-public primary constructors inside inline/value classes.</li> <li>Fix: Allow init blocks inside inline/value classes.</li> <li>Fix: Omit redundant <code>abstract</code> modifiers on members inside interfaces</li> </ul>"},{"location":"changelog/#version-172","title":"Version 1.7.2","text":"<p>2020-10-20</p> <ul> <li>New: Detect expression bodies with <code>return\u00b7</code> and <code>throw\u00b7</code> prefixes.</li> <li>Fix: Omit visibility modifiers on custom accessors.</li> </ul>"},{"location":"changelog/#version-171","title":"Version 1.7.1","text":"<p>2020-10-15</p> <ul> <li>Fix: 1.7.0 was published using JDK 11 which set <code>\"org.gradle.jvm.version\"</code> to <code>\"11\"</code> in Gradle    metadata, making it impossible to use the library on earlier Java versions (see    #999). 1.7.1 is published with JDK 8, which fixes the problem.</li> </ul>"},{"location":"changelog/#version-170","title":"Version 1.7.0","text":"<p>2020-10-14</p> <ul> <li>New: Kotlin 1.4.10.</li> <li>New: Generated code is now compatible with the explicit API mode by default.</li> <li>New: Escape soft and modifier keywords, in addition to hard keywords.</li> <li>New: Improve enum constants generation for cleaner diffs.</li> <li>New: Disallow setters on immutable properties.</li> <li>New: Ensure trailing new lines in expression bodies.</li> <li>New: Ensure trailing new lines after parameterless custom setters.</li> <li>Fix: Don\u2019t auto-convert properties with custom accessors to primary constructor properties.</li> <li>Fix: Don\u2019t allow parameterless setters with body.</li> <li>Fix: Prevent auto-wrapping spaces inside escaped keywords.</li> </ul>"},{"location":"changelog/#version-160","title":"Version 1.6.0","text":"<p>2020-05-28</p> <ul> <li>New: Deprecate Mirror API integrations.</li> </ul> <p>Mirror API integrations, such as <code>TypeElement.asClassName()</code> and    <code>FunSpec.overriding(ExecutableElement)</code>, are being deprecated in this release. These KotlinPoet    APIs are most often used in annotation processors. Since kapt runs annotation processors over    stubs, which are Java files, a lot of the Kotlin-specific information gets lost in translation    and cannot be accessed by KotlinPoet through the Mirror API integrations. Examples include:</p> <ul> <li>Alias types, such as <code>kotlin.String</code>, get converted to their JVM representations, such as      <code>java.lang.String</code>.</li> <li>Type nullability information is not accessible.</li> <li><code>suspend</code> functions are seen as simple functions with an additional <code>Continuation</code> parameter.</li> </ul> <p>The correct solution is to switch to KotlinPoet-metadata or    KotlinPoet-metadata-specs API, which fetches Kotlin-specific    information from the <code>@Metadata</code> annotation and produces correct KotlinPoet Specs. We may explore    adding new metadata-based alternatives to the deprecated APIs in the future.</p> <ul> <li>New: Kotlin 1.3.72.</li> <li>New: Improve <code>MemberName</code> to support operator overloading.</li> <li>New: Support generics in <code>AnnotationSpec</code>.</li> <li>New: Add support for functional interfaces.</li> <li>New: Make more <code>FunSpec.Builder</code> members public for easier mutation.</li> <li>Fix: Properly propagate implicit type and function modifiers in nested declarations.</li> <li>Fix: Properly escape type names containing <code>$</code> character.</li> <li>Fix: Don\u2019t emit <code>LambdaTypeName</code> annotations twice.</li> <li>Fix: Preserve tags in <code>TypeName.copy()</code>.</li> </ul>"},{"location":"changelog/#version-150","title":"Version 1.5.0","text":"<p>2020-01-09</p> <p>KotlinPoet now targets JDK8, which means that executing a build that includes KotlinPoet as a  dependency on a machine with an older version of JDK installed won\u2019t work. This has no effect on  the code that KotlinPoet produces: the code can still be compiled against JDK6, as long as it  doesn\u2019t use any features that were introduced in newer releases.</p> <ul> <li>New: Kotlin 1.3.61.</li> <li>New: Add support for processing FileFacades in KotlinPoet-metadata.</li> <li>New: Add support for inner nested and companion objects on annotation classes.</li> <li>New: Improve error messages for mismatched open/close statement characters.</li> <li>New: Tag <code>AnnotationSpec</code>s with the annotation mirror when available.</li> <li>New: Include annotations on enum entries when creating <code>TypeSpec</code>s from metadata.</li> <li>Fix: Fix metadata parsing for types.</li> <li>Fix: Allow file names that are Kotlin keywords.</li> <li>Fix: Properly escape type alias names with backticks.</li> <li>Fix: Allow creating <code>TypeSpec</code>s with names that can be escaped with backticks.</li> <li>Fix: Properly escape enum constant names with backticks.</li> <li>Fix: Maintain proper ordering of properties and initializers when emitting a <code>TypeSpec</code>.    Note: with this change, any properties declared after any initializer blocks will not be    added to the primary constructor and will instead be emitted inside the <code>TypeSpec</code> body.</li> <li>Fix: Don\u2019t emit a leading new line if type KDoc is empty but parameter KDocs are present.</li> <li>Fix: Ensure KotlinPoet-metadata resolves package names properly.</li> </ul> <p>## Version 1.4.4</p> <p>2019-11-16</p> <ul> <li>Fix: Support reified inline types in KotlinPoet-metadata.</li> </ul>"},{"location":"changelog/#version-143","title":"Version 1.4.3","text":"<p>2019-10-30</p> <ul> <li>Fix: Don\u2019t emit stubs for abstract functions in KotlinPoet-metadata.</li> </ul>"},{"location":"changelog/#version-142","title":"Version 1.4.2","text":"<p>2019-10-28</p> <ul> <li>Fix: Properly handle abstract elements in KotlinPoet-metadata.</li> <li>Fix: Properly handle typealiases in KotlinPoet-metadata.</li> <li>Fix: Properly render % symbols at the end of KDocs.</li> </ul>"},{"location":"changelog/#version-141","title":"Version 1.4.1","text":"<p>2019-10-18</p> <ul> <li>New: Add annotations support to <code>TypeAliasSpec</code>.</li> <li>New: Read type annotations from Kotlin <code>Metadata</code>.</li> <li>New: Introduce <code>ImmutableKmDeclarationContainer</code>.</li> <li>Fix: Use full package name for shading <code>auto-common</code>.</li> <li>Fix: Support reading self-type variables (e.g. <code>Asset&lt;A : Asset&lt;A&gt;&gt;</code>) from Kotlin <code>Metadata</code>.</li> </ul>"},{"location":"changelog/#version-140","title":"Version 1.4.0","text":"<p>2019-09-24</p> <ul> <li>New: This release introduces the new KotlinPoet-metadata API that makes it easy to introspect    Kotlin types and build KotlinPoet Specs based on that data.</li> </ul> <p>The strategy for type introspection is driven by <code>ClassInspector</code>, which is a basic interface for    looking up JVM information about a given Class. This optionally is used by the    <code>toTypeSpec()</code>/<code>toFileSpec()</code> APIs in <code>kotlinpoet-metadata-specs</code> artifact to inform about    Classes with information that isn\u2019t present in metadata (overrides, JVM modifiers, etc). There    are two batteries-included implementations available in <code>ReflectiveClassInspector</code>    (for reflection) and <code>ElementsClassInspector</code> (for the javax Elements API in annotation    processing). These implementations are available through their respective    <code>kotlinpoet-classinspector-*</code> artifacts. For more information refer to the    KotlinPoet-metadata-specs README.</p> <p>At the time of this release the API is in experimental mode and has to be opted into via the    <code>KotlinPoetMetadataPreview</code> annotation.</p> <ul> <li>New: Kotlin 1.3.50.</li> <li>New: A new constructor to simplify creation of <code>ParameterSpec</code> instances.</li> <li>New: New <code>ClassName</code> constructors.</li> <li>New: <code>TypeName</code> and subclasses can now store tags.</li> <li>New: Optional parameters added to <code>toBuilder()</code> methods of most Specs.</li> <li>New: <code>List</code> overrides for Spec methods that accept <code>vararg</code>s.</li> <li>New: <code>CodeBlock.Builder.clear()</code> helper method.</li> <li>New: <code>FunSpec.Builder.clearBody()</code> helper method.</li> <li>Fix: Properly escape enum constant names.</li> <li>Fix: Ensure trailing newlines in KDoc and function bodies.</li> <li>Fix: <code>TypeVariableName</code>s with empty bounds will now default to <code>Any?</code>.</li> <li>Fix: Don\u2019t emit parens for primary constructors.</li> <li>Fix: <code>ClassName</code>s with empty simple names are not allowed anymore.</li> <li>Fix: Throw if names contain illegal characters that can\u2019t be escaped with backticks.</li> </ul>"},{"location":"changelog/#version-130","title":"Version 1.3.0","text":"<p>2019-05-30</p> <ul> <li>New: Don\u2019t inline annotations in the primary constructor.</li> <li>New: Force new lines when emitting primary constructors.</li> <li>New: Support using MemberNames as arguments to %N.</li> <li>New: Add more ClassName constants: ClassName.STRING, ClassName.LIST, etc.</li> <li>New: Add ClassName.constructorReference() and MemberName.reference().</li> <li>New: Make %N accept MemberNames.</li> <li>New: Escape spaces in import aliases.</li> <li>New: Escape spaces in ClassNames.</li> <li>New: Escape spaces in MemberNames.</li> <li>New: Escape imports containing spaces.</li> <li>New: Escape package name containing spaces.</li> <li>New: Use 2-space indents.</li> <li>New: Only indent one level on annotation values.</li> <li>Fix: Pass only unique originating elements to Filer.</li> <li>Fix: Fix bug with MemberNames in same package nested inside a class.</li> </ul>"},{"location":"changelog/#version-120","title":"Version 1.2.0","text":"<p>2019-03-28</p> <ul> <li>New: Add writeTo(Filer) and originating element API.</li> <li>New: Make *Spec types taggable.</li> <li>New: Make FunSpec.Builder#addCode take vararg Any?.</li> <li>Fix: Import members from default package.</li> <li>Fix: Add non-wrapping spaces in control flow creation methods.</li> <li>Fix: Named \u201cvalue\u201d argument being omitted in annotation array types.</li> </ul>"},{"location":"changelog/#version-110","title":"Version 1.1.0","text":"<p>2019-02-28</p> <ul> <li>New: Kotlin 1.3.21.</li> <li>New: Support referencing members using <code>%M</code> and <code>MemberName</code> type.</li> <li>New: Add extensions for getting a <code>MemberName</code> from a <code>ClassName</code>, <code>KClass</code> and <code>Class</code>.</li> <li>New: Allow passing <code>CodeBlock</code>s as arguments to <code>%P</code>.</li> <li>New: Allow interface delegation for objects.</li> <li>Fix: Don\u2019t emit visible whitespace in <code>toString()</code>.</li> <li>Fix: Prevent line wrapping in weird places inside function signature.</li> <li>Fix: No line wrapping between val and property name.</li> <li>Fix: Allow passing line prefix into <code>LineWrapper</code> to enable proper line wrapping in KDoc.</li> <li>Fix: Add newline for <code>TypeSpec</code> Kdoc with no tags.</li> <li>Fix: Add newline for remaining Specs.</li> <li>Fix: Fix kdoc formatting for property getter/setters.</li> <li>Fix: Don\u2019t wrap single line comments inside <code>FunSpec</code>.</li> <li>Fix: Add non-wrapping package name.</li> <li>Fix: Remove n^2 algorithm in <code>CodeWriter.resolve()</code> by precomputing all of the nested simple names of a <code>TypeSpec</code>.</li> <li>Fix: Fix edge case with empty enum classes.</li> <li>Fix: Fix Nullable Type Parameter handling in <code>KType.asTypeName()</code>.</li> <li>Fix: Fix incorrect long comment wrapping in <code>FileSpec</code>.</li> <li>Fix: Attach primary constructor param/property KDoc to the element vs emitting it inside the type header.</li> </ul>"},{"location":"changelog/#version-101","title":"Version 1.0.1","text":"<p>2019-01-02</p> <ul> <li>New: Allow enums without constants.</li> <li>New: Improved formatting of TypeSpec KDoc.</li> <li>New: Support @property and @param KDoc tags in TypeSpec.</li> <li>Fix: Use pre-formatted strings for arguments to %P.</li> </ul>"},{"location":"changelog/#version-100","title":"Version 1.0.0","text":"<p>2018-12-10</p> <ul> <li>New: Kotlin 1.3.11.</li> <li>Fix: Prevent wrapping in import statements.</li> </ul>"},{"location":"changelog/#version-100-rc3","title":"Version 1.0.0-RC3","text":"<p>2018-11-28</p> <ul> <li>New: Kotlin 1.3.10.</li> <li>New: Add <code>%P</code> placeholder for string templates.</li> <li>New: Add support for receiver kdoc.</li> <li>New: Avoid emitting <code>Unit</code> as return type.</li> <li>New: Add support for empty setters.</li> <li>New: Add checks for inline classes.</li> <li>New: Escape property and variable names if keywords.</li> <li>New: Replace <code>%&gt;</code>, <code>%&lt;</code>, <code>%[</code>, <code>%]</code> placeholders with <code>\u21e5</code>, <code>\u21e4</code>, <code>\u00ab</code>, <code>\u00bb</code>.</li> <li>New: Replace <code>%W</code> with space, and add <code>\u00b7</code> as a non-breaking space.</li> <li>New: Change <code>TypeName</code> to sealed class.</li> <li>New: Documentation improvements.</li> <li>New: Replace <code>TypeName</code> modifier methods with <code>copy()</code>.</li> <li>New: Rename members of <code>WildcardTypeName</code> to match with the producer/consumer generics model.</li> <li>New: Rename <code>TypeName.nullable</code> into <code>TypeName.isNullable</code>.</li> <li>New: Rename <code>LambdaTypeName.suspending</code> into <code>LambdaTypeName.isSuspending</code>.</li> <li>New: Rename <code>TypeVariableName.reified</code> into <code>TypeVariableName.isReified</code>.</li> <li>Fix: Emit star-projection only for types with <code>Any?</code> upper bound.</li> <li>Fix: Fold property with escaped name.</li> </ul>"},{"location":"changelog/#version-100-rc2","title":"Version 1.0.0-RC2","text":"<p>2018-10-22</p> <ul> <li>New: Kotlin 1.2.71.</li> <li>New: README improvements.</li> <li>New: Allow opening braces and params in <code>beginControlFlow()</code>.</li> <li>New: Add KDoc to <code>ParameterSpec</code>, collapse into parent KDoc.</li> <li>New: Support <code>TypeVariable</code>s in <code>PropertySpec</code>.</li> <li>New: Add parens for annotated types in <code>LambdaTypeName</code>.</li> <li>New: Improve error messaging and documentation for inline properties.</li> <li>New: Allow sealed classes to declare abstract properties.</li> <li>New: Added <code>buildCodeBlock()</code> helper function.</li> <li>New: Allow using <code>CodeBlock</code>s with statements as property initializers and default parameter values.</li> <li>New: Rename <code>NameAllocator.clone()</code> into `NameAllocator.copy().</li> <li>New: Rename <code>TypeName.asNonNullable()</code> to <code>TypeName.asNonNull()</code>.</li> <li>New: Remove <code>PropertySpec.varBuilder()</code> (use <code>mutable()</code> instead).</li> <li>New: Allow importing top-level members in default package.</li> <li>New: Add overloads to add KDoc to return type.</li> <li>Fix: Distinguishing <code>IntArray</code> and <code>Array&lt;Int&gt;</code> when creating <code>TypeName</code>.</li> <li>Fix: Use <code>TypeName</code> instead of <code>ClassName</code> as parameter type of <code>plusParameter()</code>.</li> <li>Fix: Keep type-parameter variance when constructing <code>TypeName</code> from <code>KType</code>.</li> <li>Fix: Don\u2019t validate modifiers when merging properties with primary constructor parameters.</li> <li>Fix: Escape $ characters in formatted strings.</li> <li>Fix: <code>FileSpec.Builder</code> blank package and subfolder fix.</li> <li>Fix: Append new line at end of parameter KDoc.</li> <li>Fix: Add parameter KDoc in <code>toBuilder()</code>.</li> </ul>"},{"location":"changelog/#version-100-rc1","title":"Version 1.0.0-RC1","text":"<p>2018-07-16</p> <ul> <li>New: Escape keywords in imports and canonical class names.</li> <li>New: Improve <code>external</code> support.</li> <li>New: Extensions for <code>KType</code> and <code>KTypeParameter</code>.</li> <li>New: Add builder methods to simplify adding common kotlin.jvm annotations.</li> <li>New: Enums are able to have companion objects.</li> <li>New: Add missing primaryConstructor &amp; companionObject to <code>TypeSpec#toBuilder()</code>.</li> <li>New: Make subtype checking vals inside Kind public.</li> <li>New: Escape (class/property/function/variable) names automatically if they contain space, hyphen, or other symbols.</li> <li>New: Improve <code>ParameterizedTypeName</code> API.</li> <li>New: Add <code>WildcardTypeName.STAR</code> constant.</li> <li>New: Expose mutable builder properties and move their validations to build-time.</li> <li>Fix: Use regular indents for parameter lists.</li> <li>Fix: Inline annotations on properties defined in primary constructor.</li> <li>Fix: Use <code>Any?</code> as the default type variable bounds.</li> <li>Fix: Fix importing annotated <code>TypeName</code>.</li> <li>Fix: If any primary constructor property has KDoc, put properties on new lines.</li> <li>Fix: Properly emit where block in type signature.</li> <li>Fix: Avoid type name collisions in primary constructor.</li> <li>Fix: Remove implicit <code>TypeVariable</code> bound when more bounds are added.</li> <li>Fix: Combine annotations and modifiers from constructor params and properties.</li> <li>Fix: Replace delegate constructor args along with the constructor.</li> </ul>"},{"location":"changelog/#version-070","title":"Version 0.7.0","text":"<p>2018-02-16</p> <ul> <li>New: Increase indent to 4 spaces.</li> <li>New: Delegate super interfaces as constructor parameters.</li> <li>New: Support <code>PropertySpec</code>s as <code>CodeBlock</code> literals.</li> <li>New: Support KDoc for <code>TypeAliasSpec</code>.</li> <li>New: Allow for adding an initializer block inside a companion object.</li> <li>New: Escape name in <code>ParameterSpec</code> which is also a keyword.</li> <li>New: Escape names in statements.</li> <li>New: Set com.squareup.kotlinpoet as automatic module name.</li> <li>New: Support suspending lambda types.</li> <li>New: Support named <code>LambdaTypeName</code> parameters.</li> <li>New: Support dynamic type.</li> <li>New: Disallow wildcard imports.</li> <li>New: Depend on Kotlin 1.2.21.</li> <li>Fix: Correct handling of super-classes/interfaces on anonymous classes.</li> <li>Fix: Fix boundary filtering to <code>Any?</code>.</li> <li>Fix: Wrap long property initializers.</li> <li>Fix: Fix formatting and indentation of parameter lists.</li> </ul>"},{"location":"changelog/#version-060","title":"Version 0.6.0","text":"<p>2017-11-03</p> <ul> <li>New: Support lambda extensions.</li> <li>New: Support renames in imports like <code>import bar.Bar as bBar</code>.</li> <li>New: Support extension and inline properties.</li> <li>New: Support reified types.</li> <li>New: Expose enclosed types inside <code>LambdaTypeName</code>.</li> <li>New: Depend on Kotlin Kotlin 1.1.51.</li> <li>New: Improved API and formatting of annotations.</li> <li>New: Improved multiplatform support.</li> <li>Fix: Escape function and package names if they are a Kotlin keyword.</li> <li>Fix: Properly format WildcardTypeName\u2019s class declaration.</li> </ul>"},{"location":"changelog/#version-050","title":"Version 0.5.0","text":"<p>2017-09-13</p> <ul> <li>New: Rename <code>addFun()</code> to <code>addFunction()</code>.</li> <li>New: Rename <code>KotlinFile</code> to <code>FileSpec</code>.</li> <li>New: Rename <code>KotlinFile.addFileAnnotation()</code> to <code>addAnnotation()</code>.</li> <li>New: Rename <code>KotlinFile.addFileComment()</code> to <code>addComment()</code>.</li> <li>New: Support cross-platform code, including <code>HEADER</code> and <code>IMPL</code> modifiers.</li> <li>New: Support type variables for type aliases.</li> <li>New: Support constructor delegation.</li> <li>New: Support named companion objects.</li> <li>New: Depend on Kotlin 1.1.4-3.</li> <li>Fix: Format one parameter per line when there are more than two parameters.</li> <li>Fix: Don\u2019t emit braces when the constructor body is empty.</li> <li>Fix: Do not invoke superclass constructor when no primary constructor.</li> <li>Fix: Enforce the right modifiers on functions.</li> </ul>"},{"location":"changelog/#version-040","title":"Version 0.4.0","text":"<p>2017-08-08</p> <ul> <li>New: Change KotlinPoet\u2019s extensions like <code>asClassName()</code> to be top-level functions.</li> <li>New: Add declaration-site variance support.</li> <li>New: Improve handling of single expression bodies.</li> <li>New: Support file annotations.</li> <li>New: Support imports from the top-level file.</li> <li>New: Accept superclass constructor parameters.</li> <li>New: Support primary constructors using the <code>constructor</code> keyword.</li> <li>Fix: Don\u2019t emit setter parameter types.</li> <li>Fix: Support Kotlin keywords in <code>NameAllocator</code>.</li> <li>Fix: Emit the right default parameters for primary constructors.</li> <li>Fix: Format annotations properly when used as parameters.</li> <li>Fix: Recognize imports when emitting nullable types.</li> <li>Fix: Call through to the superclass constructor when superclass has a no-args constructor.</li> <li>Fix: Omit class braces if all properties are declared in primary constructor.</li> <li>Fix: Don\u2019t emit empty class bodies.</li> <li>Fix: Emit the right syntax for declaring multiple generic type constraints.</li> <li>Fix: Support properties on objects, companions and interfaces.</li> <li>Fix: Use <code>AnnotationSpec</code> for throws.</li> </ul>"},{"location":"changelog/#version-030","title":"Version 0.3.0","text":"<p>2017-06-11</p> <ul> <li>New: Objects and companion objects.</li> <li>New: <code>TypeAliasSpec</code> to create type aliases.</li> <li>New: <code>LambdaTypeName</code> to create lambda types.</li> <li>New: Collapse property declarations into constructor params.</li> <li>New: Extension and invoke functions for creating type names: <code>Runnable::class.asClassName()</code>.</li> <li>New: Basic support for expression bodies.</li> <li>New: Basic support for custom accessors.</li> <li>New: Remove <code>Filer</code> writing and originating elements concept. These stem from <code>javac</code> annotation    processors.</li> <li>Fix: Generate valid annotation classes.</li> <li>Fix: Use <code>KModifier</code> for varargs.</li> <li>Fix: Use <code>ParameterizedTypeName</code> for array types.</li> <li>Fix: Extract Kotlin name from <code>KClass</code> instead of Java name.</li> <li>Fix: Emit valid class literals: <code>Double::class</code> instead of <code>Double.class</code>.</li> <li>Fix: Emit modifiers in the expected order.</li> <li>Fix: Emit the correct syntax for enum classes and overridden members.</li> </ul>"},{"location":"changelog/#version-020","title":"Version 0.2.0","text":"<p>2017-05-21</p> <ul> <li>New: Flip API signatures to be (name, type) instead of (type, name).</li> <li>New: Support for nullable types.</li> <li>New: Support delegated properties.</li> <li>New: Extension functions.</li> <li>New: Support top-level properties.</li> <li>Fix: Inheritance should use <code>:</code> instead of <code>extends</code> and <code>implements</code>.</li> <li>Fix: Make initializerBlock emit <code>init {}</code>.</li> </ul>"},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<p>2017-05-16</p> <ul> <li>Initial public release.</li> </ul>"},{"location":"code-block-format-strings/","title":"Code Block Format Strings","text":"<p>Code blocks may specify the values for their placeholders in a few ways. Only one style may be used for each operation on a code block.</p>"},{"location":"code-block-format-strings/#relative-arguments","title":"Relative Arguments","text":"<p>Pass an argument value for each placeholder in the format string to <code>CodeBlock.add()</code>. In each example, we generate code to say \u201cI ate 3 tacos\u201d</p> <pre><code>CodeBlock.builder().add(\"I ate %L %L\", 3, \"tacos\")\n</code></pre>"},{"location":"code-block-format-strings/#positional-arguments","title":"Positional Arguments","text":"<p>Place an integer index (1-based) before the placeholder in the format string to specify which argument to use.</p> <pre><code>CodeBlock.builder().add(\"I ate %2L %1L\", \"tacos\", 3)\n</code></pre>"},{"location":"code-block-format-strings/#named-arguments","title":"Named Arguments","text":"<p>Use the syntax <code>%argumentName:X</code> where <code>X</code> is the format character and call <code>CodeBlock.addNamed()</code> with a map containing all argument keys in the format string. Argument names use characters in <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, and <code>_</code>, and must start with a lowercase character.</p> <pre><code>val map = LinkedHashMap&lt;String, Any&gt;()\nmap += \"food\" to \"tacos\"\nmap += \"count\" to 3\nCodeBlock.builder().addNamed(\"I ate %count:L %food:L\", map)\n</code></pre>"},{"location":"code-control-flow/","title":"Code &amp; Control Flow","text":"<p>Most of KotlinPoet\u2019s API uses immutable Kotlin objects. There\u2019s also builders, method chaining and varargs to make the API friendly. KotlinPoet offers models for Kotlin files (<code>FileSpec</code>), classes, interfaces &amp; objects (<code>TypeSpec</code>), type aliases (<code>TypeAliasSpec</code>), properties (<code>PropertySpec</code>), functions &amp; constructors (<code>FunSpec</code>), parameters (<code>ParameterSpec</code>) and annotations (<code>AnnotationSpec</code>).</p> <p>But the body of methods and constructors is not modeled. There\u2019s no expression class, no statement class or syntax tree nodes. Instead, KotlinPoet uses strings for code blocks, and you can take advantage of Kotlin\u2019s multiline strings to make this look nice:</p> <pre><code>val main = FunSpec.builder(\"main\")\n  .addCode(\"\"\"\n    |var total = 0\n    |for (i in 0..&lt;10) {\n    |    total += i\n    |}\n    |\"\"\".trimMargin())\n  .build()\n</code></pre> <p>Which generates this:</p> <pre><code>fun main() {\n  var total = 0\n  for (i in 0..&lt;10) {\n    total += i\n  }\n}\n</code></pre> <p>There are additional APIs to assist with newlines, braces and indentation:</p> <pre><code>val main = FunSpec.builder(\"main\")\n  .addStatement(\"var total = 0\")\n  .beginControlFlow(\"for (i in 0..&lt;10)\")\n  .addStatement(\"total += i\")\n  .endControlFlow()\n  .build()\n</code></pre> <p>This example is lame because the generated code is constant! Suppose instead of just adding 0 to 10, we want to make the operation and range configurable. Here\u2019s a method that generates a method:</p> <pre><code>private fun computeRange(name: String, from: Int, to: Int, op: String): FunSpec {\n  return FunSpec.builder(name)\n    .returns(Int::class)\n    .addStatement(\"var result = 1\")\n    .beginControlFlow(\"for (i in $from..&lt;$to)\")\n    .addStatement(\"result = result $op i\")\n    .endControlFlow()\n    .addStatement(\"return result\")\n    .build()\n}\n</code></pre> <p>And here\u2019s what we get when we call <code>computeRange(\"multiply10to20\", 10, 20, \"*\")</code>:</p> <pre><code>fun multiply10to20(): kotlin.Int {\n  var result = 1\n  for (i in 10..&lt;20) {\n    result = result * i\n  }\n  return result\n}\n</code></pre> <p>Methods generating methods! And since KotlinPoet generates source instead of bytecode, you can read through it to make sure it\u2019s right.</p>"},{"location":"constructors/","title":"Constructors","text":"<p><code>FunSpec</code> is a slight misnomer; it can also be used for constructors:</p> <pre><code>val flux = FunSpec.constructorBuilder()\n  .addParameter(\"greeting\", String::class)\n  .addStatement(\"this.%N = %N\", \"greeting\", \"greeting\")\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addProperty(\"greeting\", String::class, KModifier.PRIVATE)\n  .addFunction(flux)\n  .build()\n</code></pre> <p>Which generates this:</p> <pre><code>class HelloWorld {\n  private val greeting: String\n\n  constructor(greeting: String) {\n    this.greeting = greeting\n  }\n}\n</code></pre> <p>For the most part, constructors work just like methods. When emitting code, KotlinPoet will place constructors before methods in the output file.</p> <p>Often times you\u2019ll need to generate the primary constructor for a class:</p> <pre><code>val helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .primaryConstructor(flux)\n  .addProperty(\"greeting\", String::class, KModifier.PRIVATE)\n  .build()\n</code></pre> <p>This code, however, generates the following:</p> <pre><code>class HelloWorld(greeting: String) {\n  private val greeting: String\n\n  init {\n    this.greeting = greeting\n  }\n}\n</code></pre> <p>By default, KotlinPoet won\u2019t merge primary constructor parameters and properties, even if they share the same name. To achieve the effect, you have to tell KotlinPoet that the property is initialized via the constructor parameter:</p> <pre><code>val flux = FunSpec.constructorBuilder()\n  .addParameter(\"greeting\", String::class)\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .primaryConstructor(flux)\n  .addProperty(\n    PropertySpec.builder(\"greeting\", String::class)\n      .initializer(\"greeting\")\n      .addModifiers(KModifier.PRIVATE)\n      .build()\n  )\n  .build()\n</code></pre> <p>Now we\u2019re getting the following output:</p> <pre><code>class HelloWorld(private val greeting: String)\n</code></pre> <p>Notice that KotlinPoet omits <code>{}</code> for classes with empty bodies.</p>"},{"location":"context-parameters/","title":"Context Parameters","text":"<p>KotlinPoet supports Kotlin\u2019s context parameters feature, which allows you to add context parameters to functions and properties. Context parameters are added using the <code>contextParameter()</code> method:</p> <pre><code>val greet = FunSpec.builder(\"greet\")\n  .contextParameter(\"user\", String::class)\n  .addStatement(\"println(\\\"Hello, ${'$'}user!\\\")\")\n  .build()\n</code></pre> <p>The code above generates:</p> <pre><code>context(user: kotlin.String)\npublic fun greet() {\n  println(\"Hello, $user!\")\n}\n</code></pre> <p>You can add multiple context parameters:</p> <pre><code>val loggerType = ClassName(\"java.util.logging\", \"Logger\")\nval configType = ClassName(\"com.example\", \"Config\")\n\nval logger = ContextParameter(\"logger\", loggerType)\nval config = ContextParameter(\"config\", configType)\n\nval processData = FunSpec.builder(\"processData\")\n  .contextParameter(logger)\n  .contextParameter(config)\n  .addStatement(\"%N.info(\\\"Processing with config: ${'$'}%N\\\")\", logger, config)\n  .build()\n</code></pre> <p>This generates:</p> <pre><code>context(logger: com.example.Logger, config: com.example.Config)\npublic fun processData() {\n  logger.info(\"Processing with config: $config\")\n}\n</code></pre> <p>Note: context receivers and context parameters cannot be used together.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p> <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>./gradlew clean build</code>.</p> <p>When creating a pull request, please add a row in the changelog with the patch description and PR # to <code>Unreleased</code> section.</p> <p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>"},{"location":"enums/","title":"Enums","text":"<p>Use <code>enumBuilder</code> to create the enum type, and <code>addEnumConstant()</code> for each value:</p> <pre><code>val helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n  .addEnumConstant(\"ROCK\")\n  .addEnumConstant(\"SCISSORS\")\n  .addEnumConstant(\"PAPER\")\n  .build()\n</code></pre> <p>To generate this:</p> <pre><code>enum class Roshambo {\n  ROCK,\n\n  SCISSORS,\n\n  PAPER\n}\n</code></pre> <p>Fancy enums are supported, where the enum values override methods or call a superclass constructor. Here\u2019s a comprehensive example:</p> <pre><code>val helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n  .primaryConstructor(\n    FunSpec.constructorBuilder()\n      .addParameter(\"handsign\", String::class)\n      .build()\n  )\n  .addEnumConstant(\n    \"ROCK\", TypeSpec.anonymousClassBuilder()\n      .addSuperclassConstructorParameter(\"%S\", \"fist\")\n      .addFunction(\n        FunSpec.builder(\"toString\")\n          .addModifiers(KModifier.OVERRIDE)\n          .addStatement(\"return %S\", \"avalanche!\")\n          .returns(String::class)\n          .build()\n      )\n      .build()\n  )\n  .addEnumConstant(\n    \"SCISSORS\", TypeSpec.anonymousClassBuilder()\n      .addSuperclassConstructorParameter(\"%S\", \"peace\")\n      .build()\n  )\n  .addEnumConstant(\n    \"PAPER\", TypeSpec.anonymousClassBuilder()\n      .addSuperclassConstructorParameter(\"%S\", \"flat\")\n      .build()\n  )\n  .addProperty(\n    PropertySpec.builder(\"handsign\", String::class, KModifier.PRIVATE)\n      .initializer(\"handsign\")\n      .build()\n  )\n  .build()\n</code></pre> <p>Which generates this:</p> <pre><code>enum class Roshambo(private val handsign: String) {\n  ROCK(\"fist\") {\n    override fun toString(): String = \"avalanche!\"\n  },\n\n  SCISSORS(\"peace\"),\n\n  PAPER(\"flat\");\n}\n</code></pre>"},{"location":"functions/","title":"Functions","text":"<p>All of the above functions have a code body. Use <code>KModifier.ABSTRACT</code> to get a function without any body. This is only legal if it is enclosed by an abstract class or an interface.</p> <pre><code>val flux = FunSpec.builder(\"flux\")\n  .addModifiers(KModifier.ABSTRACT, KModifier.PROTECTED)\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addModifiers(KModifier.ABSTRACT)\n  .addFunction(flux)\n  .build()\n</code></pre> <p>Which generates this:</p> <pre><code>abstract class HelloWorld {\n  protected abstract fun flux()\n}\n</code></pre> <p>The other modifiers work where permitted.</p> <p>Methods also have parameters, varargs, KDoc, annotations, type variables, return type and receiver type for extension functions. All of these are configured with <code>FunSpec.Builder</code>.</p>"},{"location":"functions/#extension-functions","title":"Extension functions","text":"<p>Extension functions can be generated by specifying a <code>receiver</code>.</p> <pre><code>val square = FunSpec.builder(\"square\")\n  .receiver(Int::class)\n  .returns(Int::class)\n  .addStatement(\"var s = this * this\")\n  .addStatement(\"return s\")\n  .build()\n</code></pre> <p>Which outputs:</p> <pre><code>fun Int.square(): Int {\n  val s = this * this\n  return s\n}\n</code></pre>"},{"location":"functions/#single-expression-functions","title":"Single-expression functions","text":"<p>KotlinPoet can recognize single-expression functions and print them out properly. It treats each function with a body that starts with <code>return</code> as a single-expression function:</p> <pre><code>val abs = FunSpec.builder(\"abs\")\n  .addParameter(\"x\", Int::class)\n  .returns(Int::class)\n  .addStatement(\"return if (x &lt; 0) -x else x\")\n  .build()\n</code></pre> <p>Which outputs:</p> <pre><code>fun abs(x: Int): Int = if (x &lt; 0) -x else x\n</code></pre>"},{"location":"functions/#default-function-arguments","title":"Default function arguments","text":"<p>Consider the example below. Function argument <code>b</code> has a default value of 0 to avoid overloading this function.</p> <pre><code>fun add(a: Int, b: Int = 0) {\n  print(\"a + b = ${a + b}\")\n}\n</code></pre> <p>Use the <code>defaultValue()</code> builder function to declare default value for a function argument.</p> <pre><code>FunSpec.builder(\"add\")\n  .addParameter(\"a\", Int::class)\n  .addParameter(\n    ParameterSpec.builder(\"b\", Int::class)\n      .defaultValue(\"%L\", 0)\n      .build()\n  )\n  .addStatement(\"print(\\\"a + b = ${a + b}\\\")\")\n  .build()\n</code></pre>"},{"location":"functions/#wrapping-is-explicit","title":"Wrapping is explicit","text":"<p>In order to guarantee code correctness, starting in version 2.0, KotlinPoet will never replace spaces found in blocks of code with new line symbols, even in cases when the line of code exceeds the length limit. Let\u2019s take this function for example:</p> <pre><code>val funSpec = FunSpec.builder(\"foo\")\n  .addStatement(\"return (100..10000).map { number -&gt; number * number }.map { number -&gt; number.toString() }.also { string -&gt; println(string) }\")\n  .build()\n</code></pre> <p>The function will always be printed out like this:</p> <pre><code>public fun foo() = (100..10000).map { number -&gt; number * number }.map { number -&gt; number.toString() }.also { string -&gt; println(string) }\n</code></pre> <p>While the output is correct, the resulting line of code is quite long and hard to read. KotlinPoet is unable to understand the context of the expression and adjust the formatting for you, but there\u2019s a trick you can use to declare a breaking space - use the <code>\u2662</code> symbol where you know it\u2019s safe to optionally wrap the line. Let\u2019s apply this to our example:</p> <pre><code>val funSpec = FunSpec.builder(\"foo\")\n  .addStatement(\"return (100..10000).map { number -&gt;\u2662number * number\u2662}.map { number -&gt;\u2662number.toString()\u2662}.also { string -&gt;\u2662println(string)\u2662}\")\n  .build()\n</code></pre> <p>This will now produce the following result:</p> <pre><code>public fun foo(): Unit = (100..10000).map { number -&gt; number * number }.map { number -&gt;\n  number.toString() }.also { string -&gt; println(string) }\n</code></pre> <p>This is slightly better, but far from perfect - feel free to play around with other formatting modifiers, such as the standard <code>\\n</code> character which KotlinPoet honors, or the indentation formatters (<code>\u21e5</code> and <code>\u21e4</code>) that the library ships with (see the documentation for <code>CodeBlock</code> for more information).</p> <p>Lastly, imperfect formatting is a known limitation of the library, as KotlinPoet by design prioritizes correctness of generated code over style. If correct and clean formatting is important for your use case, please consider post-processing KotlinPoet\u2019s output using a dedicated code formatter.</p>"},{"location":"interfaces/","title":"Interfaces","text":"<p>KotlinPoet has no trouble with interfaces. Note that interface methods must always be <code>ABSTRACT</code>. The modifier is necessary when defining the interface:</p> <pre><code>val helloWorld = TypeSpec.interfaceBuilder(\"HelloWorld\")\n  .addProperty(\"buzz\", String::class)\n  .addFunction(\n    FunSpec.builder(\"beep\")\n      .addModifiers(KModifier.ABSTRACT)\n      .build()\n  )\n  .build()\n</code></pre> <p>But these modifiers are omitted when the code is generated. These are the default so we don\u2019t need to include them for <code>kotlinc</code>\u2019s benefit!</p> <pre><code>interface HelloWorld {\n  val buzz: String\n\n  fun beep()\n}\n</code></pre> <p>Kotlin 1.4 adds support for functional interfaces via <code>fun interface</code> syntax. To create this in KotlinPoet, use <code>TypeSpec.funInterfaceBuilder()</code>.</p> <pre><code>val helloWorld = TypeSpec.funInterfaceBuilder(\"HelloWorld\")\n  .addFunction(\n    FunSpec.builder(\"beep\")\n      .addModifiers(KModifier.ABSTRACT)\n      .build()\n  )\n  .build()\n\n// Generates...\nfun interface HelloWorld {\n  fun beep()\n}\n</code></pre>"},{"location":"interop-javapoet/","title":"JavaPoet Extensions for KotlinPoet","text":"<p><code>interop:javapoet</code> is an interop API for converting JavaPoet types to KotlinPoet types. This is particularly useful for projects that support code gen in multiple languages and want to easily be able to jump between.</p> <p>Note that this API is currently in preview and subject to API changes. Usage of them requires opting in to the <code>@KotlinPoetJavaPoetPreview</code> annotation.</p>"},{"location":"interop-javapoet/#examples","title":"Examples","text":"<p>Typealiases for common conflicting type names</p> <pre><code>// Points to com.squareup.kotlinpoet.TypeName\nKTypeName\n// Points to com.squareup.javapoet.TypeName\nJTypeName\n</code></pre> <p>Convert between a <code>JTypeName</code> and <code>KTypeName</code></p> <p>Most usages of these can run through the <code>toKTypeName()</code> and <code>toJTypeName()</code> extensions.</p> <pre><code>val jType = JTypeName.get(\"com.example\", \"Taco\")\n\n// Returns a KotlinPoet `ClassName` of value `com.example.Taco`\nval kType = jType.toKTypeName()\n\n// Returns a JavaPoet `ClassName` of value `com.example.Taco`\nval jType2 = kType.toJTypeName()\n</code></pre>"},{"location":"interop-javapoet/#intrinsics","title":"Intrinsics","text":"<p>Kotlin supports a number of intrinsic types that live in the <code>kotlin</code> package, such as primitives, <code>List</code>, <code>String</code>, <code>IntArray</code>, etc. Where possible, interop will best-effort attempt to convert to the idiomatic Kotlin type when converting from the Java type.</p>"},{"location":"interop-javapoet/#lossy-conversions","title":"Lossy Conversions","text":"<p>Kotlin has more expressive types in some regards. These cannot be simply expressed in JavaPoet and are subject to lossy conversions.</p> <p>Examples include:</p> <ul> <li>Nullability</li> <li>Nullable types in Kotlin will appear as normal types in JavaPoet.</li> <li>Collection mutability</li> <li>Immutable Kotlin collections will convert to their standard (mutable) Java analogs.</li> <li>Java collections will convert to immutable Kotlin analogs, erring on the side of safety in generated public APIs</li> <li>Unsigned types</li> </ul>"},{"location":"interop-kotlin-metadata/","title":"KotlinPoet-metadata","text":"<p><code>interop:kotlin-metadata</code> is an API for working with Kotlin <code>@Metadata</code> annotations. Its API sits atop kotlin-metadata, offering extensions for its types + JVM metadata information. This can be used to read Kotlin language semantics off of <code>Class</code> or <code>TypeElement</code> <code>@Metadata</code> annotations.</p>"},{"location":"interop-kotlin-metadata/#example","title":"Example","text":"<pre><code>data class Taco(val seasoning: String, val soft: Boolean) {\n  fun prepare() {\n\n  }\n}\n\nval kmClass = Taco::class.toKmClass()\n\n// Now you can access misc information about Taco from a Kotlin lens\nprintln(kmClass.name)\nkmClass.properties.forEach { println(it.name) }\nkmClass.functions.forEach { println(it.name) }\n</code></pre>"},{"location":"interop-kotlin-metadata/#flags","title":"Flags","text":"<p>There are a number of boolean flags available to types as well under <code>Flags.kt</code>. These read the underlying kotlin-metadata <code>Flags</code> property.</p> <p>Using the Taco example above, we can glean certain information:</p> <pre><code>println(\"Is class? ${kmClass.isClass}\")\nprintln(\"Is data class? ${kmClass.isData}\")\n</code></pre>"},{"location":"interop-kotlin-metadata/#interop-with-kotlinpoet","title":"Interop with KotlinPoet","text":"<p><code>interop:kotlin-metadata</code> offers an API for converting core kotlin-metadata <code>Km</code> types to KotlinPoet source representations of their APIs. This includes full type resolution, signatures, enclosed elements, and general stub source representations of the underlying API.</p>"},{"location":"interop-kotlin-metadata/#example_1","title":"Example","text":"<pre><code>data class Taco(val seasoning: String, val soft: Boolean) {\n  fun prepare() {\n  }\n}\n\nval typeSpec = Taco::class.toTypeSpec()\n\n// Or FileSpec\nval fileSpec = Taco::class.toFileSpec()\n</code></pre>"},{"location":"interop-kotlin-metadata/#source-representation","title":"Source representation","text":"<p>The generated representations are a best effort representation of the underlying source code. This means that synthetic elements will be excluded from generation. Kotlin-specific language features like lambdas or delegation will be coerced to their idiomatic source form.</p> <p>To aid with this, <code>toTypeSpec()</code> and <code>toFileSpec()</code> accept optional <code>ClassInspector</code> instances to assist in parsing/understanding the underlying JVM code. This is important for things like annotations, companion objects, certain JVM modifiers, overrides, and more. While it is optional, represented sources can be incomplete without this information available. Reflective and javax <code>Elements</code> implementations are available under the <code>com.squareup.kotlinpoet.metadata.classinspectors</code> package.</p> <p>Generated sources are solely stub implementations, meaning implementation details of elements like functions, property getters, and delegated properties are simply stubbed with <code>TODO()</code> placeholders.</p>"},{"location":"interop-kotlin-metadata/#known-limitations","title":"Known limitations","text":"<ul> <li>Only <code>KotlinClassMetadata.Class</code> and <code>KotlinClassMetadata.FileFacade</code> are supported for now. No support for <code>SyntheticClass</code>, <code>MultiFileClassFacade</code>, or <code>MultiFileClassPart</code></li> <li><code>@JvmOverloads</code> annotations are only supported with <code>ElementsClassInspector</code> and not reflection.</li> <li>Non-const literal values are only supported with <code>ElementsClassInspector</code> and not reflection.</li> <li>ClassInspector data sourced from <code>synthetic</code> constructs are only supported with   <code>ReflectiveClassInspector</code> and not elements. This is because the javax Elements API does not model   synthetic constructs. This can yield some missing information, like static companion object properties   or <code>property:</code> site target annotations.</li> <li>Annotations annotated with <code>AnnotationRetention.SOURCE</code> are not parsable in reflection nor javax elements.</li> </ul>"},{"location":"interop-ksp/","title":"KSP Extensions for KotlinPoet","text":"<p><code>interop:ksp</code> is an interop API for converting Kotlin Symbol Processing (KSP) types to KotlinPoet types and writing to KSP <code>CodeGenerator</code>.</p> <pre><code>dependencies {\n  implementation(\"com.squareup:kotlinpoet-ksp:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"interop-ksp/#examples","title":"Examples","text":"<p>Examples are based on reading the following property as a <code>KSProperty</code>:</p> <pre><code>class Taco {\n  internal inline val seasoning: String get() = \"spicy\"\n}\n</code></pre> <p>Convert a <code>KSType</code> to a <code>TypeName</code></p> <pre><code>// returns a `ClassName` of value `kotlin.String`\nseasoningKsProperty.type.toTypeName()\n</code></pre> <p>Convert a <code>Modifier</code> to a <code>KModifier</code></p> <pre><code>// returns `[KModifier.INLINE]`\nseasoningKsProperty.modifiers.mapNotNull { it.toKModifier() }\n</code></pre> <p>Convert a <code>Visibility</code> to a <code>KModifier</code></p> <pre><code>// returns `KModifier.INTERNAL`\nseasoningKsProperty.getVisibility().toKModifier()\n</code></pre> <p>Write to <code>CodeGenerator</code></p> <p>To write a <code>FileSpec</code> to a KSP <code>CodeGenerator</code>, simply call the <code>FileSpec.writeTo(CodeGenerator, ...)</code> extension function.</p> <pre><code>fileSpec.writeTo(codeGenerator)\n</code></pre>"},{"location":"interop-ksp/#type-parameters","title":"Type Parameters","text":"<p>Type parameters can be declared on classes, functions, and typealiases. These parameters are then available to all of its enclosed elements. In order for these elements to resolve these in KSP, you must be able to reference these type parameters by their index.</p> <p>In <code>kotlinpoet-ksp</code> this is orchestrated by the <code>TypeParameterResolver</code> API, which can be passed into most <code>toTypeName()</code> (or similar) functions to give them access to enclosing type parameters that they may reference.</p> <p>The canonical way to create an instance of this is to call <code>toTypeParameterResolver()</code> on a <code>List&lt;KSTypeParameter&gt;</code>.</p> <p>Consider the following class and function</p> <pre><code>abstract class Taco&lt;T&gt; {\n  abstract val seasoning: T\n}\n</code></pre> <p>To properly resolve the type of <code>seasoning</code>, we need to pass the class <code>TypeParameterResolver</code> to <code>toTypeName()</code> so that it can properly resolve it.</p> <pre><code>val classTypeParams = ksClassDeclaration.typeParameters.toTypeParameterResolver()\n// returns `T`\nval seasoningType = seasoningKsProperty.type.toTypeName(classTypeParams)\n</code></pre> <p><code>TypeParameterResolver</code> is also composable to allow for multi-level nesting. <code>toTypeParameterResolver()</code> has an optional <code>parent</code> parameter to provide a parent instance.</p> <p>Consider our previous example again, but this time with a function that defines its own type parameters.</p> <pre><code>class Taco&lt;T&gt; {\n  fun &lt;E&gt; getShellOfType(param1: E, param2: T) {\n\n  }\n}\n</code></pre> <p>To resolve its parameters, we need to create a <code>TypeParameterResolver</code> from the function\u2019s <code>typeParameters</code> and compose it with the enclosing class\u2019s type parameters as a <code>parent</code>.</p> <pre><code>val classTypeParams = ksClassDeclaration.typeParameters.toTypeParameterResolver()\nval functionTypeParams = ksFunction.typeParameters.toTypeParameterResolver(parent = classTypeParams)\n// returns `[E, T]`\nval seasoningType = ksFunction.parameterTypes.map { it.toTypeName(functionTypeParams) }\n</code></pre>"},{"location":"interop-ksp/#incremental-processing","title":"Incremental Processing","text":"<p>KSP supports incremental processing as long as symbol processors properly indicate originating files in generated new files and whether or not they are <code>aggregating</code>. <code>kotlinpoet-ksp</code> supports this via <code>OriginatingKSFiles</code>, which is a simple API that sits atop KotlinPoet\u2019s <code>Taggable</code> API. To use this, simply add relevant originating files to any <code>TypeSpec</code>, <code>TypeAliasSpec</code>, <code>PropertySpec</code>, or <code>FunSpec</code> builders.</p> <pre><code>val functionBuilder = FunSpec.builder(\"sayHello\")\n  .addOriginatingKSFile(sourceKsFile)\n  .build()\n</code></pre> <p>Like KotlinPoet\u2019s originating elements support for javac annotation processors, calling the <code>FileSpec.writeTo(CodeGenerator, ...)</code> function will automatically collect and de-dupe these originating <code>KSFile</code> references and automatically assemble them in the underlying <code>Dependencies</code> for KSP\u2019s reference.</p> <p>Optionally you can define your own collection of files and pass them to the <code>writeTo</code> function, but usually you don\u2019t need to do this manually.</p> <p>Lastly - <code>FileSpec.writeTo(CodeGenerator, ...)</code> also requires you to specify if your processor is aggregating or not via required parameter by the same name.</p>"},{"location":"interop-ksp/#typealias-handling","title":"TypeAlias Handling","text":"<p>For <code>typealias</code> types, KSP interop will store a <code>TypeAliasTag</code> in the <code>TypeName</code>\u2019s tags with a reference to the abbreviated type. This can be useful for APIs that want to resolve all un-aliased types.</p>"},{"location":"kotlin-reflect/","title":"kotlin-reflect","text":"<p>To generate source code from any <code>KType</code>, including information that\u2019s not accessible to the builtin reflection APIs, KotlinPoet depends on kotlin-reflect. <code>kotlin-reflect</code> can read the metadata of your classes and access this extra information. KotlinPoet can for an example, read the type parameters and their variance from a generic <code>KType</code> and generate appropriate source code.</p> <p><code>kotlin-reflect</code> is a relatively big dependency though and in some cases it is desirable to remove it from the final executable to save some space and/or simplify the proguard/R8 setup (for example for a Gradle plugin that generates Kotlin code). It is possible to do so and still use most of the KotlinPoet APIs:</p> <pre><code>dependencies {\n  implementation(\"com.squareup:kotlinpoet:&lt;version&gt;\") {\n    exclude(module = \"kotlin-reflect\")\n  }\n}\n</code></pre> <p>The main APIs that require <code>kotlin-reflect</code> are <code>KType.asTypeName()</code> and <code>typeNameOf&lt;T&gt;()</code>. If you\u2019re calling one of these without <code>kotlin-reflect</code> in the classpath and the type is generic or has annotations you will get a crash.</p> <p>You can replace it with code that passes type parameters or annotations explicitly and doesn\u2019t need <code>kotlin-reflect</code>. For example:</p> <pre><code>// Replace\n// kotlin-reflect needed\nval typeName = typeNameOf&lt;List&lt;Int?&gt;&gt;()\n\n// With\n// kotlin-reflect not needed\nval typeName =\n  List::class.asClassName().parameterizedBy(Int::class.asClassName().copy(nullable = true))\n</code></pre>"},{"location":"l-for-literals/","title":"%L for Literals","text":"<p>Although Kotlin\u2019s string templates usually work well in cases when you want to include literals into generated code, KotlinPoet offers additional syntax inspired-by but incompatible-with <code>String.format()</code>. It accepts <code>%L</code> to emit a literal value in the output. This works just like <code>Formatter</code>\u2019s <code>%s</code>:</p> <pre><code>private fun computeRange(name: String, from: Int, to: Int, op: String): FunSpec {\n  return FunSpec.builder(name)\n    .returns(Int::class)\n    .addStatement(\"var result = 0\")\n    .beginControlFlow(\"for (i in %L..&lt;%L)\", from, to)\n    .addStatement(\"result = result %L i\", op)\n    .endControlFlow()\n    .addStatement(\"return result\")\n    .build()\n}\n</code></pre> <p>Literals are emitted directly to the output code with no escaping. Arguments for literals may be strings, primitives, and a few KotlinPoet types described below.</p>"},{"location":"m-for-members/","title":"%M for Members","text":"<p>Similar to types, KotlinPoet has a special placeholder for members (functions and properties), which comes handy when your code needs to access top-level members and members declared inside objects. Use <code>%M</code> to reference members, pass an instance of <code>MemberName</code> as the argument for the placeholder, and KotlinPoet will handle imports automatically:</p> <pre><code>val createTaco = MemberName(\"com.squareup.tacos\", \"createTaco\")\nval isVegan = MemberName(\"com.squareup.tacos\", \"isVegan\")\nval file = FileSpec.builder(\"com.squareup.example\", \"TacoTest\")\n  .addFunction(\n    FunSpec.builder(\"main\")\n      .addStatement(\"val taco = %M()\", createTaco)\n      .addStatement(\"println(taco.%M)\", isVegan)\n      .build()\n  )\n  .build()\nprintln(file)\n</code></pre> <p>The code above generates the following file:</p> <pre><code>package com.squareup.example\n\nimport com.squareup.tacos.createTaco\nimport com.squareup.tacos.isVegan\n\nfun main() {\n  val taco = createTaco()\n  println(taco.isVegan)\n}\n</code></pre> <p>As you can see, it\u2019s also possible to use <code>%M</code> to reference extension functions and properties. You just need to make sure the member can be imported without simple name collisions, otherwise importing will fail and the code generator output will not pass compilation. There\u2019s a way to work around such cases though - use <code>FileSpec.addAliasedImport()</code> to create an alias for a clashing <code>MemberName</code>:</p> <pre><code>val createTaco = MemberName(\"com.squareup.tacos\", \"createTaco\")\nval createCake = MemberName(\"com.squareup.cakes\", \"createCake\")\nval isTacoVegan = MemberName(\"com.squareup.tacos\", \"isVegan\")\nval isCakeVegan = MemberName(\"com.squareup.cakes\", \"isVegan\")\nval file = FileSpec.builder(\"com.squareup.example\", \"Test\")\n  .addAliasedImport(isTacoVegan, \"isTacoVegan\")\n  .addAliasedImport(isCakeVegan, \"isCakeVegan\")\n  .addFunction(\n    FunSpec.builder(\"main\")\n      .addStatement(\"val taco = %M()\", createTaco)\n      .addStatement(\"val cake = %M()\", createCake)\n      .addStatement(\"println(taco.%M)\", isTacoVegan)\n      .addStatement(\"println(cake.%M)\", isCakeVegan)\n      .build()\n  )\n  .build()\nprintln(file)\n</code></pre> <p>KotlinPoet will produce an aliased import for <code>com.squareup.tacos2.isVegan</code>:</p> <pre><code>package com.squareup.example\n\nimport com.squareup.cakes.createCake\nimport com.squareup.tacos.createTaco\nimport com.squareup.cakes.isVegan as isCakeVegan\nimport com.squareup.tacos.isVegan as isTacoVegan\n\nfun main() {\n  val taco = createTaco()\n  val cake = createCake()\n  println(taco.isTacoVegan)\n  println(cake.isCakeVegan)\n}\n</code></pre>"},{"location":"m-for-members/#membername-and-operators","title":"MemberName and operators","text":"<p>MemberName also supports operators, you can use <code>MemberName(String, KOperator)</code> or <code>MemberName(ClassName, KOperator)</code> to import and reference operators.</p> <pre><code>val taco = ClassName(\"com.squareup.tacos\", \"Taco\")\nval meat = ClassName(\"com.squareup.tacos.ingredient\", \"Meat\")\nval iterator = MemberName(\"com.squareup.tacos.internal\", KOperator.ITERATOR)\nval minusAssign = MemberName(\"com.squareup.tacos.internal\", KOperator.MINUS_ASSIGN)\nval file = FileSpec.builder(\"com.example\", \"Test\")\n  .addFunction(\n    FunSpec.builder(\"makeTacoHealthy\")\n      .addParameter(\"taco\", taco)\n      .beginControlFlow(\"for (ingredient %M taco)\", iterator)\n      .addStatement(\"if (ingredient is %T) taco %M ingredient\", meat, minusAssign)\n      .endControlFlow()\n      .addStatement(\"return taco\")\n      .build()\n  )\n  .build()\nprintln(file)\n</code></pre> <p>KotlinPoet will import the extension operator functions and emit the operator.</p> <pre><code>package com.example\n\nimport com.squareup.tacos.Taco\nimport com.squareup.tacos.ingredient.Meat\nimport com.squareup.tacos.internal.iterator\nimport com.squareup.tacos.internal.minusAssign\n\nfun makeTacoHealthy(taco: Taco) {\n  for (ingredient in taco) {\n    if (ingredient is Meat) taco -= ingredient\n  }\n  return taco\n}\n</code></pre>"},{"location":"n-for-names/","title":"%N for Names","text":"<p>Generated code is often self-referential. Use <code>%N</code> to refer to another generated declaration by its name. Here\u2019s a method that calls another:</p> <pre><code>fun byteToHex(b: Int): String {\n  val result = CharArray(2)\n  result[0] = hexDigit((b ushr 4) and 0xf)\n  result[1] = hexDigit(b and 0xf)\n  return String(result)\n}\n\nfun hexDigit(i: Int): Char {\n  return (if (i &lt; 10) i + '0'.toInt() else i - 10 + 'a'.toInt()).toChar()\n}\n</code></pre> <p>When generating the code above, we pass the <code>hexDigit()</code> method as an argument to the <code>byteToHex()</code> method using <code>%N</code>:</p> <pre><code>val hexDigit = FunSpec.builder(\"hexDigit\")\n  .addParameter(\"i\", Int::class)\n  .returns(Char::class)\n  .addStatement(\"return (if (i &lt; 10) i + '0'.toInt() else i - 10 + 'a'.toInt()).toChar()\")\n  .build()\n\nval byteToHex = FunSpec.builder(\"byteToHex\")\n  .addParameter(\"b\", Int::class)\n  .returns(String::class)\n  .addStatement(\"val result = CharArray(2)\")\n  .addStatement(\"result[0] = %N((b ushr 4) and 0xf)\", hexDigit)\n  .addStatement(\"result[1] = %N(b and 0xf)\", hexDigit)\n  .addStatement(\"return String(result)\")\n  .build()\n</code></pre> <p>Another handy feature that <code>%N</code> provides is automatically escaping names that contain illegal identifier characters with double ticks. Suppose your code creates a <code>MemberName</code> with a Kotlin keyword as the simple name:</p> <pre><code>val taco = ClassName(\"com.squareup.tacos\", \"Taco\")\nval packager = ClassName(\"com.squareup.tacos\", \"TacoPackager\")\nval file = FileSpec.builder(\"com.example\", \"Test\")\n  .addFunction(\n    FunSpec.builder(\"packageTacos\")\n      .addParameter(\"tacos\", LIST.parameterizedBy(taco))\n      .addParameter(\"packager\", packager)\n      .addStatement(\"packager.%N(tacos)\", packager.member(\"package\"))\n      .build()\n  )\n  .build()\n</code></pre> <p><code>%N</code> will escape the name for you, ensuring that the output will pass compilation:</p> <pre><code>package com.example\n\nimport com.squareup.tacos.Taco\nimport com.squareup.tacos.TacoPackager\nimport kotlin.collections.List\n\nfun packageTacos(tacos: List&lt;Taco&gt;, packager: TacoPackager) {\n  packager.`package`(tacos)\n}\n</code></pre>"},{"location":"objects/","title":"Objects","text":"<p>KotlinPoet supports objects:</p> <pre><code>val helloWorld = TypeSpec.objectBuilder(\"HelloWorld\")\n  .addProperty(\n    PropertySpec.builder(\"buzz\", String::class)\n      .initializer(\"%S\", \"buzz\")\n      .build()\n  )\n  .addFunction(\n    FunSpec.builder(\"beep\")\n      .addStatement(\"println(%S)\", \"Beep!\")\n      .build()\n  )\n  .build()\n</code></pre> <p>Similarly, you can create companion objects and add them to classes using <code>addType()</code>:</p> <pre><code>val companion = TypeSpec.companionObjectBuilder()\n  .addProperty(\n    PropertySpec.builder(\"buzz\", String::class)\n      .initializer(\"%S\", \"buzz\")\n      .build()\n  )\n  .addFunction(\n    FunSpec.builder(\"beep\")\n      .addStatement(\"println(%S)\", \"Beep!\")\n      .build()\n  )\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addType(companion)\n  .build()\n</code></pre> <p>You can provide an optional name for a companion object.</p>"},{"location":"p-for-string-templates/","title":"%P for String Templates","text":"<p><code>%S</code> also handles the escaping of dollar signs (<code>$</code>), to avoid inadvertent creation of string templates, which may fail to compile in generated code:</p> <pre><code>val stringWithADollar = \"Your total is \" + \"$\" + \"50\"\nval funSpec = FunSpec.builder(\"printTotal\")\n  .returns(String::class)\n  .addStatement(\"return %S\", stringWithADollar)\n  .build()\n</code></pre> <p>produces:</p> <pre><code>fun printTotal(): String = \"Your total is ${'$'}50\"\n</code></pre> <p>If you need to generate string templates, use <code>%P</code>, which doesn\u2019t escape dollars:</p> <pre><code>val amount = 50\nval stringWithADollar = \"Your total is \" + \"$\" + \"amount\"\nval funSpec = FunSpec.builder(\"printTotal\")\n  .returns(String::class)\n  .addStatement(\"return %P\", stringWithADollar)\n  .build()\n</code></pre> <p>produces:</p> <pre><code>fun printTotal(): String = \"Your total is $amount\"\n</code></pre> <p>You can also use <code>CodeBlock</code>s as arguments to <code>%P</code>, which is handy when you need to reference importable types or members inside the string template:</p> <pre><code>val file = FileSpec.builder(\"com.example\", \"Digits\")\n  .addFunction(\n    FunSpec.builder(\"print\")\n      .addParameter(\"digits\", IntArray::class)\n      .addStatement(\"println(%P)\", buildCodeBlock {\n        val contentToString = MemberName(\"kotlin.collections\", \"contentToString\")\n        add(\"These are the digits: \\${digits.%M()}\", contentToString)\n      })\n      .build()\n  )\n  .build()\nprintln(file)\n</code></pre> <p>The snippet above will produce the following output, handling the imports properly:</p> <pre><code>package com.example\n\nimport kotlin.IntArray\nimport kotlin.collections.contentToString\n\nfun print(digits: IntArray) {\n  println(\"\"\"These are the digits: ${digits.contentToString()}\"\"\")\n}\n</code></pre>"},{"location":"parameters/","title":"Parameters","text":"<p>Declare parameters on methods and constructors with either <code>ParameterSpec.builder()</code> or <code>FunSpec</code>\u2019s convenient <code>addParameter()</code> API:</p> <pre><code>val android = ParameterSpec.builder(\"android\", String::class)\n  .defaultValue(\"\\\"pie\\\"\")\n  .build()\n\nval welcomeOverlords = FunSpec.builder(\"welcomeOverlords\")\n  .addParameter(android)\n  .addParameter(\"robot\", String::class)\n  .build()\n</code></pre> <p>The code above generates:</p> <pre><code>fun welcomeOverlords(android: String = \"pie\", robot: String) {\n}\n</code></pre> <p>The extended <code>Builder</code> form is necessary when the parameter has annotations (such as <code>@Inject</code>).</p>"},{"location":"properties/","title":"Properties","text":"<p>Like parameters, properties can be created either with builders or by using convenient helper methods:</p> <pre><code>val android = PropertySpec.builder(\"android\", String::class)\n  .addModifiers(KModifier.PRIVATE)\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addProperty(android)\n  .addProperty(\"robot\", String::class, KModifier.PRIVATE)\n  .build()\n</code></pre> <p>Which generates:</p> <pre><code>class HelloWorld {\n  private val android: String\n\n  private val robot: String\n}\n</code></pre> <p>The extended <code>Builder</code> form is necessary when a field has KDoc, annotations, or a field initializer. Field initializers use the same <code>String.format()</code>-like syntax as the code blocks above:</p> <pre><code>val android = PropertySpec.builder(\"android\", String::class)\n  .addModifiers(KModifier.PRIVATE)\n  .initializer(\"%S + %L\", \"Oreo v.\", 8.1)\n  .build()\n</code></pre> <p>Which generates:</p> <pre><code>private val android: String = \"Oreo v.\" + 8.1\n</code></pre> <p>By default <code>PropertySpec.Builder</code> produces <code>val</code> properties. Use <code>mutable()</code> if you need a <code>var</code>:</p> <pre><code>val android = PropertySpec.builder(\"android\", String::class)\n  .mutable()\n  .addModifiers(KModifier.PRIVATE)\n  .initializer(\"%S + %L\", \"Oreo v.\", 8.1)\n  .build()\n</code></pre>"},{"location":"properties/#inline-properties","title":"Inline properties","text":"<p>The way KotlinPoet models inline properties deserves special mention. The following snippet of code:</p> <pre><code>val android = PropertySpec.builder(\"android\", String::class)\n  .mutable()\n  .addModifiers(KModifier.INLINE)\n  .build()\n</code></pre> <p>will produce an error:</p> <pre><code>java.lang.IllegalArgumentException: KotlinPoet doesn't allow setting the inline modifier on\nproperties. You should mark either the getter, the setter, or both inline.\n</code></pre> <p>Indeed, a property marked with <code>inline</code> should have at least one accessor which will be inlined by the compiler. Let\u2019s add a getter to this property:</p> <pre><code>val android = PropertySpec.builder(\"android\", String::class)\n  .mutable()\n  .getter(\n    FunSpec.getterBuilder()\n      .addModifiers(KModifier.INLINE)\n      .addStatement(\"return %S\", \"foo\")\n      .build()\n  )\n  .build()\n</code></pre> <p>The result is the following:</p> <pre><code>var android: kotlin.String\n  inline get() = \"foo\"\n</code></pre> <p>Now, what if we wanted to add a non-inline setter to the property above? We can do so without modifying any of the code we wrote previously:</p> <pre><code>val android = PropertySpec.builder(\"android\", String::class)\n  .mutable()\n  .getter(\n    FunSpec.getterBuilder()\n      .addModifiers(KModifier.INLINE)\n      .addStatement(\"return %S\", \"foo\")\n      .build()\n  )\n  .setter(\n    FunSpec.setterBuilder()\n      .addParameter(\"value\", String::class)\n      .build()\n  )\n  .build()\n</code></pre> <p>We get the expected result:</p> <pre><code>var android: kotlin.String\n  inline get() = \"foo\"\n  set(`value`) {\n  }\n</code></pre> <p>Finally, if we go back and add <code>KModifier.INLINE</code> to the setter, KotlinPoet can wrap it nicely and produce the following result:</p> <pre><code>inline var android: kotlin.String\n  get() = \"foo\"\n  set(`value`) {\n  }\n</code></pre> <p>Removing the modifier from either the getter or the setter will unwrap the expression back.</p> <p>If, on the other hand, KotlinPoet had allowed marking a property <code>inline</code> directly, the programmer would have had to manually add/remove the modifier whenever the state of the accessors changes in order to get correct and compilable output. We\u2019re solving this problem by making accessors the source of truth for the <code>inline</code> modifier.</p>"},{"location":"s-for-strings/","title":"%S for Strings","text":"<p>When emitting code that includes string literals, we can use <code>%S</code> to emit a string, complete with wrapping quotation marks and escaping. Here\u2019s a program that emits 3 methods, each of which returns its own name:</p> <pre><code>fun main(args: Array&lt;String&gt;) {\n  val helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addFunction(whatsMyNameYo(\"slimShady\"))\n    .addFunction(whatsMyNameYo(\"eminem\"))\n    .addFunction(whatsMyNameYo(\"marshallMathers\"))\n    .build()\n\n  val kotlinFile = FileSpec.builder(\"com.example.helloworld\", \"HelloWorld\")\n    .addType(helloWorld)\n    .build()\n\n  kotlinFile.writeTo(System.out)\n}\n\nprivate fun whatsMyNameYo(name: String): FunSpec {\n  return FunSpec.builder(name)\n    .returns(String::class)\n    .addStatement(\"return %S\", name)\n    .build()\n}\n</code></pre> <p>In this case, using <code>%S</code> gives us quotation marks:</p> <pre><code>class HelloWorld {\n  fun slimShady(): String = \"slimShady\"\n\n  fun eminem(): String = \"eminem\"\n\n  fun marshallMathers(): String = \"marshallMathers\"\n}\n</code></pre>"},{"location":"t-for-types/","title":"%T for Types","text":"<p>KotlinPoet has rich built-in support for types, including automatic generation of <code>import</code> statements. Just use <code>%T</code> to reference types:</p> <pre><code>val today = FunSpec.builder(\"today\")\n  .returns(Date::class)\n  .addStatement(\"return %T()\", Date::class)\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addFunction(today)\n  .build()\n\nval kotlinFile = FileSpec.builder(\"com.example.helloworld\", \"HelloWorld\")\n  .addType(helloWorld)\n  .build()\n\nkotlinFile.writeTo(System.out)\n</code></pre> <p>That generates the following <code>.kt</code> file, complete with the necessary <code>import</code>:</p> <pre><code>package com.example.helloworld\n\nimport java.util.Date\n\nclass HelloWorld {\n  fun today(): Date = Date()\n}\n</code></pre> <p>We passed <code>Date::class</code> to reference a class that just-so-happens to be available when we\u2019re generating code. This doesn\u2019t need to be the case. Here\u2019s a similar example, but this one references a class that doesn\u2019t exist (yet):</p> <pre><code>val hoverboard = ClassName(\"com.mattel\", \"Hoverboard\")\n\nval tomorrow = FunSpec.builder(\"tomorrow\")\n  .returns(hoverboard)\n  .addStatement(\"return %T()\", hoverboard)\n  .build()\n</code></pre> <p>And that not-yet-existent class is imported as well:</p> <pre><code>package com.example.helloworld\n\nimport com.mattel.Hoverboard\n\nclass HelloWorld {\n  fun tomorrow(): Hoverboard = Hoverboard()\n}\n</code></pre> <p>The <code>ClassName</code> type is very important, and you\u2019ll need it frequently when you\u2019re using KotlinPoet. It can identify any declared class. Declared types are just the beginning of Kotlin\u2019s rich type system: we also have arrays, parameterized types, wildcard types, lambda types and type variables. KotlinPoet has classes for building each of these:</p> <pre><code>import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy\nimport com.squareup.kotlinpoet.STAR\n\nval hoverboard = ClassName(\"com.mattel\", \"Hoverboard\")\nval list = ClassName(\"kotlin.collections\", \"List\")\nval arrayList = ClassName(\"kotlin.collections\", \"ArrayList\")\nval listOfHoverboards = list.parameterizedBy(hoverboard)\nval arrayListOfHoverboards = arrayList.parameterizedBy(hoverboard)\n\nval thing = ClassName(\"com.misc\", \"Thing\")\nval array = ClassName(\"kotlin\", \"Array\")\nval producerArrayOfThings = array.parameterizedBy(WildcardTypeName.producerOf(thing))\n\nval beyond = FunSpec.builder(\"beyond\")\n  .returns(listOfHoverboards)\n  .addStatement(\"val result = %T()\", arrayListOfHoverboards)\n  .addStatement(\"result += %T()\", hoverboard)\n  .addStatement(\"result += %T()\", hoverboard)\n  .addStatement(\"result += %T()\", hoverboard)\n  .addStatement(\"return result\")\n  .build()\n\nval printThings = FunSpec.builder(\"printThings\")\n  .addParameter(\"things\", producerArrayOfThings)\n  .addStatement(\"println(things)\")\n  .build()\n\nval printKClass = FunSpec.builder(\"printKClass\")\n  .addParameter(\"kClass\", KClass::class.asClassName().parameterizedBy(STAR))\n  .addStatement(\"println(kClass)\")\n  .build()\n</code></pre> <p>The <code>STAR</code> is represented as <code>*</code> in KotlinPoet. You can find more in the KDoc.</p> <p>KotlinPoet will decompose each type and import its components where possible.</p> <pre><code>package com.example.helloworld\n\nimport com.mattel.Hoverboard\nimport com.misc.Thing\nimport kotlin.Array\nimport kotlin.collections.ArrayList\nimport kotlin.collections.List\nimport kotlin.reflect.KClass\n\nclass HelloWorld {\n  fun beyond(): List&lt;Hoverboard&gt; {\n    val result = ArrayList&lt;Hoverboard&gt;()\n    result += Hoverboard()\n    result += Hoverboard()\n    result += Hoverboard()\n    return result\n  }\n\n  fun printThings(things: Array&lt;out Thing&gt;) {\n    println(things)\n  }\n\n  fun printKClass(kClass: KClass&lt;*&gt;) {\n    println(kClass)\n  }\n}\n</code></pre>"},{"location":"t-for-types/#nullable-types","title":"Nullable Types","text":"<p>KotlinPoet supports nullable types. To convert a <code>TypeName</code> into its nullable counterpart, use the <code>copy()</code> method with <code>nullable</code> parameter set to <code>true</code>:</p> <pre><code>val java = PropertySpec.builder(\"java\", String::class.asTypeName().copy(nullable = true))\n  .mutable()\n  .addModifiers(KModifier.PRIVATE)\n  .initializer(\"null\")\n  .build()\n\nval helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n  .addProperty(java)\n  .addProperty(\"kotlin\", String::class, KModifier.PRIVATE)\n  .build()\n</code></pre> <p>generates:</p> <pre><code>class HelloWorld {\n  private var java: String? = null\n\n  private val kotlin: String\n}\n</code></pre>"},{"location":"type-aliases/","title":"Type Aliases","text":"<p>KotlinPoet provides API for creating Type Aliases, which supports simple class names, parameterized types and lambdas:</p> <pre><code>val k = TypeVariableName(\"K\")\nval t = TypeVariableName(\"T\")\n\nval fileTable = Map::class.asClassName()\n  .parameterizedBy(k, Set::class.parameterizedBy(File::class))\n\nval predicate = LambdaTypeName.get(\n  parameters = arrayOf(t),\n  returnType = Boolean::class.asClassName()\n)\nval helloWorld = FileSpec.builder(\"com.example\", \"HelloWorld\")\n  .addTypeAlias(TypeAliasSpec.builder(\"Word\", String::class).build())\n  .addTypeAlias(\n    TypeAliasSpec.builder(\"FileTable\", fileTable)\n      .addTypeVariable(k)\n      .build()\n  )\n  .addTypeAlias(\n    TypeAliasSpec.builder(\"Predicate\", predicate)\n      .addTypeVariable(t)\n      .build()\n  )\n  .build()\n</code></pre> <p>Which generates the following:</p> <pre><code>package com.example\n\nimport java.io.File\nimport kotlin.Boolean\nimport kotlin.String\nimport kotlin.collections.Map\nimport kotlin.collections.Set\n\ntypealias Word = String\n\ntypealias FileTable&lt;K&gt; = Map&lt;K, Set&lt;File&gt;&gt;\n\ntypealias Predicate&lt;T&gt; = (T) -&gt; Boolean\n</code></pre> <p>Type aliases can also be added to types (classes, interfaces, objects) as well:</p> <p>Note: Nested type aliases are a beta feature in Kotlin. See the official documentation here for more details.</p> <pre><code>val taco = TypeSpec.classBuilder(\"Taco\")\n  .addTypeAlias(TypeAliasSpec.builder(\"Topping\", String::class).build())\n  .build()\n</code></pre> <p>Which generates the following:</p> <pre><code>package com.squareup.tacos\n\nimport kotlin.String\n\npublic class Taco {\n  public typealias Topping = String\n}\n</code></pre>"}]}